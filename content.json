{"meta":{"title":"Huang's Blog","subtitle":"","description":"The blog site of Fan Huang","author":"Fan Huang","url":"http://muyuhuatang.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-09-24T16:10:27.797Z","updated":"2020-09-24T16:10:27.797Z","comments":true,"path":"categories/index.html","permalink":"http://muyuhuatang.github.io/categories/index.html","excerpt":"","text":""},{"title":"About me","date":"2020-10-01T04:13:18.604Z","updated":"2020-10-01T04:13:18.604Z","comments":true,"path":"about/index.html","permalink":"http://muyuhuatang.github.io/about/index.html","excerpt":"","text":"Education:Central South University, Hunan Province, ChinaBachelor’s degree of Engineering - Computer Science and Technology Nanyang Technological University, SingaporeMaster of Science - Information Systems Contact me&#102;&#104;&#117;&#97;&#x6e;&#103;&#x31;&#x38;&#49;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d; / &#102;&#x68;&#x75;&#97;&#x6e;&#103;&#x30;&#x30;&#x34;&#64;&#x65;&#46;&#x6e;&#116;&#x75;&#46;&#x65;&#x64;&#117;&#46;&#115;&#x67; This is my CV (2020.09.24)"},{"title":"tags","date":"2020-09-08T07:42:33.473Z","updated":"2020-09-08T07:42:33.473Z","comments":true,"path":"tags/index.html","permalink":"http://muyuhuatang.github.io/tags/index.html","excerpt":"","text":""},{"title":"schedule","date":"2020-09-24T16:10:21.058Z","updated":"2020-09-24T16:10:21.058Z","comments":true,"path":"schedule/index.html","permalink":"http://muyuhuatang.github.io/schedule/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"Census Income Dataset","date":"2020-10-08T07:49:42.000Z","updated":"2020-10-08T07:49:42.000Z","comments":true,"path":"2020/10/08/Census Income Dataset/","link":"","permalink":"http://muyuhuatang.github.io/2020/10/08/Census%20Income%20Dataset/","excerpt":"","text":"Data Science, Classification AnalysisData Cleaning, Feature Engineering, Imputation, and Classification.This Notepad has been designed to be run on top of the Jupyter Tensorflow Docker instance found in the link below: https://github.com/jupyter/docker-stacks/tree/master/tensorflow-notebook Checking Number of CPU’s available to Docker containerIdeally, and for this Notebook to run in a reasonable time, your Docker container should have 4 cores or more available. 1!cat /proc/cpuinfo | awk &#x27;/^processor/&#123;print $3&#125;&#x27; | tail -1 5 Import Standard Python Libraries12import io, os, sys, types, time, datetime, math, random, requests, subprocess, tempfilefrom io import StringIO, BytesIO Packages InstallWe’ll now install a few more libraries. This is an easy way to install libraries in a way that are recognised and managed by conda. Do this once and then comment it out for subsequent runs. 12#!conda install --yes -c conda-forge missingno#!conda install --yes -c anaconda requests Packages UpdateThere’s a lot of packages available to us, and most of them were installed when running the dockerfile that created the docker instance. Let’s make sure they are all up to date. Do this once and then comment it out for subsequent runs. 1#!conda update --yes --all Packages ImportThese are all the packages we’ll be using. Importing individual libraries make it easy for us to use them without having to call the parent libraries. 12345678910111213141516171819202122232425262728293031323334353637383940414243# Data Manipulation import numpy as npimport pandas as pd# Visualization import matplotlib.pyplot as pltimport missingnoimport seaborn as snsfrom pandas.plotting import scatter_matrixfrom mpl_toolkits.mplot3d import Axes3D# Feature Selection and Encodingfrom sklearn.feature_selection import RFE, RFECVfrom sklearn.svm import SVRfrom sklearn.decomposition import PCAfrom sklearn.preprocessing import OneHotEncoder, LabelEncoder, label_binarize# Machine learning import sklearn.ensemble as skefrom sklearn import datasets, model_selection, tree, preprocessing, metrics, linear_modelfrom sklearn.svm import LinearSVCfrom sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifierfrom sklearn.neighbors import KNeighborsClassifierfrom sklearn.naive_bayes import GaussianNBfrom sklearn.linear_model import LinearRegression, LogisticRegression, Ridge, Lasso, SGDClassifierfrom sklearn.tree import DecisionTreeClassifierimport tensorflow as tf# Grid and Random Searchimport scipy.stats as stfrom scipy.stats import randint as sp_randintfrom sklearn.model_selection import GridSearchCVfrom sklearn.model_selection import RandomizedSearchCV# Metricsfrom sklearn.metrics import precision_recall_fscore_support, roc_curve, auc# Managing Warnings import warningswarnings.filterwarnings(&#x27;ignore&#x27;)# Plot the Figures Inline%matplotlib inline Listing Installed PackagesWe could list all installed packages to check whether a package has already been installed. 123456conda_packages_list = BytesIO(subprocess.Popen([&quot;conda&quot;, &quot;list&quot;], stdout=subprocess.PIPE).communicate()[0])conda_packages_list = pd.read_csv(conda_packages_list, names=[&#x27;Package Name&#x27;,&#x27;Version&#x27;,&#x27;Python Version&#x27;,&#x27;Repo&#x27;,&#x27;Other&#x27;], delim_whitespace=True, engine=&#x27;python&#x27;, skiprows=3)conda_packages_list.head(5) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; Package Name Version Python Version Repo Other 0 _libgcc_mutex 0.1 conda_forge conda-forge NaN 1 _openmp_mutex 4.5 1_llvm conda-forge NaN 2 absl-py 0.10.0 pypi_0 pypi NaN 3 aiohttp 3.6.2 pypi_0 pypi NaN 4 alembic 1.4.3 pyh9f0ad1d_0 conda-forge NaN ObjectiveIn this Jupyter Notepad, we will using the Census Income Dataset to predict whether an individual’s income exceeds $50K/yr based on census data. The dataset can be found here: https://archive.ics.uci.edu/ml/datasets/adult Data Download and LoadingLet’s download the data and save it to a folder in our local directory called ‘dataset’. Download it once, and then comment the code out for subsequent runs. After downloading the data, we load it directly from Disk into a Pandas Dataframe in Memory. Depending on the memory available to the Docker instance, this may be a problem. The data comes separated into the Training and Test datasets. We will join the two for data exploration, and then separate them again before running our algorithms. 123456789101112131415161718# DownloadDATASET = ( &quot;http://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data&quot;, &quot;http://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.names&quot;, &quot;http://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.test&quot;,)def download_data(path=&#x27;dataset&#x27;, urls=DATASET): if not os.path.exists(path): os.mkdir(path) for url in urls: response = requests.get(url) name = os.path.basename(url) with open(os.path.join(path, name), &#x27;wb&#x27;) as f: f.write(response.content)#download_data() 123456789101112131415161718192021# Load Training and Test Data Setsheaders = [&#x27;age&#x27;, &#x27;workclass&#x27;, &#x27;fnlwgt&#x27;, &#x27;education&#x27;, &#x27;education-num&#x27;, &#x27;marital-status&#x27;, &#x27;occupation&#x27;, &#x27;relationship&#x27;, &#x27;race&#x27;, &#x27;sex&#x27;, &#x27;capital-gain&#x27;, &#x27;capital-loss&#x27;, &#x27;hours-per-week&#x27;, &#x27;native-country&#x27;, &#x27;predclass&#x27;]training_raw = pd.read_csv(&#x27;dataset/adult.data&#x27;, header=None, names=headers, sep=&#x27;,\\s&#x27;, na_values=[&quot;?&quot;], engine=&#x27;python&#x27;)test_raw = pd.read_csv(&#x27;dataset/adult.test&#x27;, header=None, names=headers, sep=&#x27;,\\s&#x27;, na_values=[&quot;?&quot;], engine=&#x27;python&#x27;, skiprows=1) 1234# Join Datasetsdataset_raw = training_raw.append(test_raw)dataset_raw.reset_index(inplace=True)dataset_raw.drop(&#x27;index&#x27;,inplace=True,axis=1) 12345678910# Displaying the size of the Dataframe in Memorydef convert_size(size_bytes): if size_bytes == 0: return &quot;0B&quot; size_name = (&quot;Bytes&quot;, &quot;KB&quot;, &quot;MB&quot;, &quot;GB&quot;, &quot;TB&quot;, &quot;PB&quot;, &quot;EB&quot;, &quot;ZB&quot;, &quot;YB&quot;) i = int(math.floor(math.log(size_bytes, 1024))) p = math.pow(1024, i) s = round(size_bytes / p, 2) return &quot;%s %s&quot; % (s, size_name[i])convert_size(dataset_raw.memory_usage().sum()) &#39;5.59 MB&#39; Data Exploration - UnivariateWhen exploring our dataset and its features, we have many options available to us. We can explore each feature individually, or compare pairs of features, finding the correlation between. Let’s start with some simple Univariate (one feature) analysis. Features can be of multiple types: Nominal: is for mutual exclusive, but not ordered, categories. Ordinal: is one where the order matters but not the difference between values. Interval: is a measurement where the difference between two values is meaningful. Ratio: has all the properties of an interval variable, and also has a clear definition of 0.0. There are multiple ways of manipulating each feature type, but for simplicity, we’ll define only two feature types: Numerical: any feature that contains numeric values. Categorical: any feature that contains categories, or text. 12# Describing all the Numerical Featuresdataset_raw.describe() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; age fnlwgt education-num capital-gain capital-loss hours-per-week count 48842.000000 4.884200e+04 48842.000000 48842.000000 48842.000000 48842.000000 mean 38.643585 1.896641e+05 10.078089 1079.067626 87.502314 40.422382 std 13.710510 1.056040e+05 2.570973 7452.019058 403.004552 12.391444 min 17.000000 1.228500e+04 1.000000 0.000000 0.000000 1.000000 25% 28.000000 1.175505e+05 9.000000 0.000000 0.000000 40.000000 50% 37.000000 1.781445e+05 10.000000 0.000000 0.000000 40.000000 75% 48.000000 2.376420e+05 12.000000 0.000000 0.000000 45.000000 max 90.000000 1.490400e+06 16.000000 99999.000000 4356.000000 99.000000 12# Describing all the Categorical Featuresdataset_raw.describe(include=[&#x27;O&#x27;]) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; workclass education marital-status occupation relationship race sex native-country predclass count 46043 48842 48842 46033 48842 48842 48842 47985 48842 unique 8 16 7 14 6 5 2 41 4 top Private HS-grad Married-civ-spouse Prof-specialty Husband White Male United-States &lt;=50K freq 33906 15784 22379 6172 19716 41762 32650 43832 24720 12# Let&#x27;s have a quick look at our datadataset_raw.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; age workclass fnlwgt education education-num marital-status occupation relationship race sex capital-gain capital-loss hours-per-week native-country predclass 0 39 State-gov 77516 Bachelors 13 Never-married Adm-clerical Not-in-family White Male 2174 0 40 United-States &lt;=50K 1 50 Self-emp-not-inc 83311 Bachelors 13 Married-civ-spouse Exec-managerial Husband White Male 0 0 13 United-States &lt;=50K 2 38 Private 215646 HS-grad 9 Divorced Handlers-cleaners Not-in-family White Male 0 0 40 United-States &lt;=50K 3 53 Private 234721 11th 7 Married-civ-spouse Handlers-cleaners Husband Black Male 0 0 40 United-States &lt;=50K 4 28 Private 338409 Bachelors 13 Married-civ-spouse Prof-specialty Wife Black Female 0 0 40 Cuba &lt;=50K 12345678910111213141516171819# Let’s plot the distribution of each featuredef plot_distribution(dataset, cols=5, width=20, height=15, hspace=0.2, wspace=0.5): plt.style.use(&#x27;seaborn-whitegrid&#x27;) fig = plt.figure(figsize=(width,height)) fig.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=wspace, hspace=hspace) rows = math.ceil(float(dataset.shape[1]) / cols) for i, column in enumerate(dataset.columns): ax = fig.add_subplot(rows, cols, i + 1) ax.set_title(column) if dataset.dtypes[column] == np.object: g = sns.countplot(y=column, data=dataset) substrings = [s.get_text()[:18] for s in g.get_yticklabels()] g.set(yticklabels=substrings) plt.xticks(rotation=25) else: g = sns.distplot(dataset[column]) plt.xticks(rotation=25) plot_distribution(dataset_raw, cols=3, width=20, height=20, hspace=0.45, wspace=0.5) 12# How many missing values are there in our dataset?missingno.matrix(dataset_raw, figsize = (30,5)) &lt;AxesSubplot:&gt; 1missingno.bar(dataset_raw, sort=&#x27;ascending&#x27;, figsize = (30,5)) &lt;AxesSubplot:&gt; Feature Cleaning, Engineering, and ImputationCleaning:To clean our data, we’ll need to work with: Missing values: Either omit elements from a dataset that contain missing values or impute them (fill them in). Special values: Numeric variables are endowed with several formalized special values including ±Inf, NA and NaN. Calculations involving special values often result in special values, and need to be handled/cleaned. Outliers: They should be detected, but not necessarily removed. Their inclusion in the analysis is a statistical decision. Obvious inconsistencies: A person’s age cannot be negative, a man cannot be pregnant and an under-aged person cannot possess a drivers license. Find the inconsistencies and plan for them. Engineering:There are multiple techniques for feature engineering: Decompose: Converting 2014-09-20T20:45:40Z into categorical attributes like hour_of_the_day, part_of_day, etc. Discretization: We can choose to either discretize some of the continuous variables we have, as some algorithms will perform faster. We are going to do both, and compare the results of the ML algorithms on both discretized and non discretised datasets. We’ll call these datasets: dataset_bin =&gt; where Continuous variables are Discretised dataset_con =&gt; where Continuous variables are Continuous Reframe Numerical Quantities: Changing from grams to kg, and losing detail might be both wanted and efficient for calculation Feature Crossing: Creating new features as a combination of existing features. Could be multiplying numerical features, or combining categorical variables. This is a great way to add domain expertise knowledge to the dataset. Imputation:We can impute missing values in a number of different ways: Hot-Deck: The technique then finds the first missing value and uses the cell value immediately prior to the data that are missing to impute the missing value. Cold-Deck: Selects donors from another dataset to complete missing data. Mean-substitution: Another imputation technique involves replacing any missing value with the mean of that variable for all other cases, which has the benefit of not changing the sample mean for that variable. Regression: A regression model is estimated to predict observed values of a variable based on other variables, and that model is then used to impute values in cases where that variable is missing. 123# To perform our data analysis, let&#x27;s create new dataframes.dataset_bin = pd.DataFrame() # To contain our dataframe with our discretised continuous variables dataset_con = pd.DataFrame() # To contain our dataframe with our continuous variables Feature PredclassThis is the feature we are trying to predict. We’ll change the string to a binary 0/1. With 1 signifying over $50K. 12345678# Let&#x27;s fix the Class Featuredataset_raw.loc[dataset_raw[&#x27;predclass&#x27;] == &#x27;&gt;50K&#x27;, &#x27;predclass&#x27;] = 1dataset_raw.loc[dataset_raw[&#x27;predclass&#x27;] == &#x27;&gt;50K.&#x27;, &#x27;predclass&#x27;] = 1dataset_raw.loc[dataset_raw[&#x27;predclass&#x27;] == &#x27;&lt;=50K&#x27;, &#x27;predclass&#x27;] = 0dataset_raw.loc[dataset_raw[&#x27;predclass&#x27;] == &#x27;&lt;=50K.&#x27;, &#x27;predclass&#x27;] = 0dataset_bin[&#x27;predclass&#x27;] = dataset_raw[&#x27;predclass&#x27;]dataset_con[&#x27;predclass&#x27;] = dataset_raw[&#x27;predclass&#x27;] 123plt.style.use(&#x27;seaborn-whitegrid&#x27;)fig = plt.figure(figsize=(20,1)) sns.countplot(y=&quot;predclass&quot;, data=dataset_bin); Feature: AgeWe will use the Pandas Cut function to bin the data in equally sized buckets. We will also add our original feature to the dataset_con dataframe. 12dataset_bin[&#x27;age&#x27;] = pd.cut(dataset_raw[&#x27;age&#x27;], 10) # discretised dataset_con[&#x27;age&#x27;] = dataset_raw[&#x27;age&#x27;] # non-discretised 1234567plt.style.use(&#x27;seaborn-whitegrid&#x27;)fig = plt.figure(figsize=(20,5)) plt.subplot(1, 2, 1)sns.countplot(y=&quot;age&quot;, data=dataset_bin);plt.subplot(1, 2, 2)sns.distplot(dataset_con.loc[dataset_con[&#x27;predclass&#x27;] == 1][&#x27;age&#x27;], kde_kws=&#123;&quot;label&quot;: &quot;&gt;$50K&quot;&#125;);sns.distplot(dataset_con.loc[dataset_con[&#x27;predclass&#x27;] == 0][&#x27;age&#x27;], kde_kws=&#123;&quot;label&quot;: &quot;&lt;$50K&quot;&#125;); Feature: Workclass1234# Can we bucket some of these groups?plt.style.use(&#x27;seaborn-whitegrid&#x27;)plt.figure(figsize=(20,3)) sns.countplot(y=&quot;workclass&quot;, data=dataset_raw); 123456789101112# There are too many groups here, we can group someof them together.# Create buckets for Workclassdataset_raw.loc[dataset_raw[&#x27;workclass&#x27;] == &#x27;Without-pay&#x27;, &#x27;workclass&#x27;] = &#x27;Not Working&#x27;dataset_raw.loc[dataset_raw[&#x27;workclass&#x27;] == &#x27;Never-worked&#x27;, &#x27;workclass&#x27;] = &#x27;Not Working&#x27;dataset_raw.loc[dataset_raw[&#x27;workclass&#x27;] == &#x27;Federal-gov&#x27;, &#x27;workclass&#x27;] = &#x27;Fed-gov&#x27;dataset_raw.loc[dataset_raw[&#x27;workclass&#x27;] == &#x27;State-gov&#x27;, &#x27;workclass&#x27;] = &#x27;Non-fed-gov&#x27;dataset_raw.loc[dataset_raw[&#x27;workclass&#x27;] == &#x27;Local-gov&#x27;, &#x27;workclass&#x27;] = &#x27;Non-fed-gov&#x27;dataset_raw.loc[dataset_raw[&#x27;workclass&#x27;] == &#x27;Self-emp-not-inc&#x27;, &#x27;workclass&#x27;] = &#x27;Self-emp&#x27;dataset_raw.loc[dataset_raw[&#x27;workclass&#x27;] == &#x27;Self-emp-inc&#x27;, &#x27;workclass&#x27;] = &#x27;Self-emp&#x27;dataset_bin[&#x27;workclass&#x27;] = dataset_raw[&#x27;workclass&#x27;]dataset_con[&#x27;workclass&#x27;] = dataset_raw[&#x27;workclass&#x27;] 123plt.style.use(&#x27;seaborn-whitegrid&#x27;)fig = plt.figure(figsize=(20,2)) sns.countplot(y=&quot;workclass&quot;, data=dataset_bin); Feature: Occupation1234# Can we bucket some of these groups?plt.style.use(&#x27;seaborn-whitegrid&#x27;)plt.figure(figsize=(20,5)) sns.countplot(y=&quot;occupation&quot;, data=dataset_raw); 123456789101112131415161718# Create buckets for Occupationdataset_raw.loc[dataset_raw[&#x27;occupation&#x27;] == &#x27;Adm-clerical&#x27;, &#x27;occupation&#x27;] = &#x27;Admin&#x27;dataset_raw.loc[dataset_raw[&#x27;occupation&#x27;] == &#x27;Armed-Forces&#x27;, &#x27;occupation&#x27;] = &#x27;Military&#x27;dataset_raw.loc[dataset_raw[&#x27;occupation&#x27;] == &#x27;Craft-repair&#x27;, &#x27;occupation&#x27;] = &#x27;Manual Labour&#x27;dataset_raw.loc[dataset_raw[&#x27;occupation&#x27;] == &#x27;Exec-managerial&#x27;, &#x27;occupation&#x27;] = &#x27;Office Labour&#x27;dataset_raw.loc[dataset_raw[&#x27;occupation&#x27;] == &#x27;Farming-fishing&#x27;, &#x27;occupation&#x27;] = &#x27;Manual Labour&#x27;dataset_raw.loc[dataset_raw[&#x27;occupation&#x27;] == &#x27;Handlers-cleaners&#x27;, &#x27;occupation&#x27;] = &#x27;Manual Labour&#x27;dataset_raw.loc[dataset_raw[&#x27;occupation&#x27;] == &#x27;Machine-op-inspct&#x27;, &#x27;occupation&#x27;] = &#x27;Manual Labour&#x27;dataset_raw.loc[dataset_raw[&#x27;occupation&#x27;] == &#x27;Other-service&#x27;, &#x27;occupation&#x27;] = &#x27;Service&#x27;dataset_raw.loc[dataset_raw[&#x27;occupation&#x27;] == &#x27;Priv-house-serv&#x27;, &#x27;occupation&#x27;] = &#x27;Service&#x27;dataset_raw.loc[dataset_raw[&#x27;occupation&#x27;] == &#x27;Prof-specialty&#x27;, &#x27;occupation&#x27;] = &#x27;Professional&#x27;dataset_raw.loc[dataset_raw[&#x27;occupation&#x27;] == &#x27;Protective-serv&#x27;, &#x27;occupation&#x27;] = &#x27;Military&#x27;dataset_raw.loc[dataset_raw[&#x27;occupation&#x27;] == &#x27;Sales&#x27;, &#x27;occupation&#x27;] = &#x27;Office Labour&#x27;dataset_raw.loc[dataset_raw[&#x27;occupation&#x27;] == &#x27;Tech-support&#x27;, &#x27;occupation&#x27;] = &#x27;Office Labour&#x27;dataset_raw.loc[dataset_raw[&#x27;occupation&#x27;] == &#x27;Transport-moving&#x27;, &#x27;occupation&#x27;] = &#x27;Manual Labour&#x27;dataset_bin[&#x27;occupation&#x27;] = dataset_raw[&#x27;occupation&#x27;]dataset_con[&#x27;occupation&#x27;] = dataset_raw[&#x27;occupation&#x27;] 123plt.style.use(&#x27;seaborn-whitegrid&#x27;)fig = plt.figure(figsize=(20,3))sns.countplot(y=&quot;occupation&quot;, data=dataset_bin); Feature: Native Country1234# Can we bucket some of these groups?plt.style.use(&#x27;seaborn-whitegrid&#x27;)plt.figure(figsize=(20,10)) sns.countplot(y=&quot;native-country&quot;, data=dataset_raw); 1234567891011121314151617181920212223242526272829303132333435363738394041424344dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Cambodia&#x27; , &#x27;native-country&#x27;] = &#x27;SE-Asia&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Canada&#x27; , &#x27;native-country&#x27;] = &#x27;British-Commonwealth&#x27; dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;China&#x27; , &#x27;native-country&#x27;] = &#x27;China&#x27; dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Columbia&#x27; , &#x27;native-country&#x27;] = &#x27;South-America&#x27; dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Cuba&#x27; , &#x27;native-country&#x27;] = &#x27;South-America&#x27; dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Dominican-Republic&#x27; , &#x27;native-country&#x27;] = &#x27;South-America&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Ecuador&#x27; , &#x27;native-country&#x27;] = &#x27;South-America&#x27; dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;El-Salvador&#x27; , &#x27;native-country&#x27;] = &#x27;South-America&#x27; dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;England&#x27; , &#x27;native-country&#x27;] = &#x27;British-Commonwealth&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;France&#x27; , &#x27;native-country&#x27;] = &#x27;Euro_Group_1&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Germany&#x27; , &#x27;native-country&#x27;] = &#x27;Euro_Group_1&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Greece&#x27; , &#x27;native-country&#x27;] = &#x27;Euro_Group_2&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Guatemala&#x27; , &#x27;native-country&#x27;] = &#x27;South-America&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Haiti&#x27; , &#x27;native-country&#x27;] = &#x27;South-America&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Holand-Netherlands&#x27; , &#x27;native-country&#x27;] = &#x27;Euro_Group_1&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Honduras&#x27; , &#x27;native-country&#x27;] = &#x27;South-America&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Hong&#x27; , &#x27;native-country&#x27;] = &#x27;China&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Hungary&#x27; , &#x27;native-country&#x27;] = &#x27;Euro_Group_2&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;India&#x27; , &#x27;native-country&#x27;] = &#x27;British-Commonwealth&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Iran&#x27; , &#x27;native-country&#x27;] = &#x27;Euro_Group_2&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Ireland&#x27; , &#x27;native-country&#x27;] = &#x27;British-Commonwealth&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Italy&#x27; , &#x27;native-country&#x27;] = &#x27;Euro_Group_1&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Jamaica&#x27; , &#x27;native-country&#x27;] = &#x27;South-America&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Japan&#x27; , &#x27;native-country&#x27;] = &#x27;APAC&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Laos&#x27; , &#x27;native-country&#x27;] = &#x27;SE-Asia&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Mexico&#x27; , &#x27;native-country&#x27;] = &#x27;South-America&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Nicaragua&#x27; , &#x27;native-country&#x27;] = &#x27;South-America&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Outlying-US(Guam-USVI-etc)&#x27; , &#x27;native-country&#x27;] = &#x27;South-America&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Peru&#x27; , &#x27;native-country&#x27;] = &#x27;South-America&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Philippines&#x27; , &#x27;native-country&#x27;] = &#x27;SE-Asia&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Poland&#x27; , &#x27;native-country&#x27;] = &#x27;Euro_Group_2&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Portugal&#x27; , &#x27;native-country&#x27;] = &#x27;Euro_Group_2&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Puerto-Rico&#x27; , &#x27;native-country&#x27;] = &#x27;South-America&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Scotland&#x27; , &#x27;native-country&#x27;] = &#x27;British-Commonwealth&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;South&#x27; , &#x27;native-country&#x27;] = &#x27;Euro_Group_2&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Taiwan&#x27; , &#x27;native-country&#x27;] = &#x27;China&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Thailand&#x27; , &#x27;native-country&#x27;] = &#x27;SE-Asia&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Trinadad&amp;Tobago&#x27; , &#x27;native-country&#x27;] = &#x27;South-America&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;United-States&#x27; , &#x27;native-country&#x27;] = &#x27;United-States&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Vietnam&#x27; , &#x27;native-country&#x27;] = &#x27;SE-Asia&#x27;dataset_raw.loc[dataset_raw[&#x27;native-country&#x27;] == &#x27;Yugoslavia&#x27; , &#x27;native-country&#x27;] = &#x27;Euro_Group_2&#x27;dataset_bin[&#x27;native-country&#x27;] = dataset_raw[&#x27;native-country&#x27;]dataset_con[&#x27;native-country&#x27;] = dataset_raw[&#x27;native-country&#x27;] 123plt.style.use(&#x27;seaborn-whitegrid&#x27;)fig = plt.figure(figsize=(20,4)) sns.countplot(y=&quot;native-country&quot;, data=dataset_bin); Feature: Education1234# Can we bucket some of these groups?plt.style.use(&#x27;seaborn-whitegrid&#x27;)plt.figure(figsize=(20,5)) sns.countplot(y=&quot;education&quot;, data=dataset_raw); 12345678910111213141516171819dataset_raw.loc[dataset_raw[&#x27;education&#x27;] == &#x27;10th&#x27; , &#x27;education&#x27;] = &#x27;Dropout&#x27;dataset_raw.loc[dataset_raw[&#x27;education&#x27;] == &#x27;11th&#x27; , &#x27;education&#x27;] = &#x27;Dropout&#x27;dataset_raw.loc[dataset_raw[&#x27;education&#x27;] == &#x27;12th&#x27; , &#x27;education&#x27;] = &#x27;Dropout&#x27;dataset_raw.loc[dataset_raw[&#x27;education&#x27;] == &#x27;1st-4th&#x27; , &#x27;education&#x27;] = &#x27;Dropout&#x27;dataset_raw.loc[dataset_raw[&#x27;education&#x27;] == &#x27;5th-6th&#x27; , &#x27;education&#x27;] = &#x27;Dropout&#x27;dataset_raw.loc[dataset_raw[&#x27;education&#x27;] == &#x27;7th-8th&#x27; , &#x27;education&#x27;] = &#x27;Dropout&#x27;dataset_raw.loc[dataset_raw[&#x27;education&#x27;] == &#x27;9th&#x27; , &#x27;education&#x27;] = &#x27;Dropout&#x27;dataset_raw.loc[dataset_raw[&#x27;education&#x27;] == &#x27;Assoc-acdm&#x27; , &#x27;education&#x27;] = &#x27;Associate&#x27;dataset_raw.loc[dataset_raw[&#x27;education&#x27;] == &#x27;Assoc-voc&#x27; , &#x27;education&#x27;] = &#x27;Associate&#x27;dataset_raw.loc[dataset_raw[&#x27;education&#x27;] == &#x27;Bachelors&#x27; , &#x27;education&#x27;] = &#x27;Bachelors&#x27;dataset_raw.loc[dataset_raw[&#x27;education&#x27;] == &#x27;Doctorate&#x27; , &#x27;education&#x27;] = &#x27;Doctorate&#x27;dataset_raw.loc[dataset_raw[&#x27;education&#x27;] == &#x27;HS-Grad&#x27; , &#x27;education&#x27;] = &#x27;HS-Graduate&#x27;dataset_raw.loc[dataset_raw[&#x27;education&#x27;] == &#x27;Masters&#x27; , &#x27;education&#x27;] = &#x27;Masters&#x27;dataset_raw.loc[dataset_raw[&#x27;education&#x27;] == &#x27;Preschool&#x27; , &#x27;education&#x27;] = &#x27;Dropout&#x27;dataset_raw.loc[dataset_raw[&#x27;education&#x27;] == &#x27;Prof-school&#x27; , &#x27;education&#x27;] = &#x27;Professor&#x27;dataset_raw.loc[dataset_raw[&#x27;education&#x27;] == &#x27;Some-college&#x27; , &#x27;education&#x27;] = &#x27;HS-Graduate&#x27;dataset_bin[&#x27;education&#x27;] = dataset_raw[&#x27;education&#x27;]dataset_con[&#x27;education&#x27;] = dataset_raw[&#x27;education&#x27;] 123plt.style.use(&#x27;seaborn-whitegrid&#x27;)fig = plt.figure(figsize=(20,4)) sns.countplot(y=&quot;education&quot;, data=dataset_bin); Feature: Marital Status123# Can we bucket some of these groups?plt.figure(figsize=(20,3)) sns.countplot(y=&quot;marital-status&quot;, data=dataset_raw); 12345678910dataset_raw.loc[dataset_raw[&#x27;marital-status&#x27;] == &#x27;Never-married&#x27; , &#x27;marital-status&#x27;] = &#x27;Never-Married&#x27;dataset_raw.loc[dataset_raw[&#x27;marital-status&#x27;] == &#x27;Married-AF-spouse&#x27; , &#x27;marital-status&#x27;] = &#x27;Married&#x27;dataset_raw.loc[dataset_raw[&#x27;marital-status&#x27;] == &#x27;Married-civ-spouse&#x27; , &#x27;marital-status&#x27;] = &#x27;Married&#x27;dataset_raw.loc[dataset_raw[&#x27;marital-status&#x27;] == &#x27;Married-spouse-absent&#x27;, &#x27;marital-status&#x27;] = &#x27;Not-Married&#x27;dataset_raw.loc[dataset_raw[&#x27;marital-status&#x27;] == &#x27;Separated&#x27; , &#x27;marital-status&#x27;] = &#x27;Separated&#x27;dataset_raw.loc[dataset_raw[&#x27;marital-status&#x27;] == &#x27;Divorced&#x27; , &#x27;marital-status&#x27;] = &#x27;Separated&#x27;dataset_raw.loc[dataset_raw[&#x27;marital-status&#x27;] == &#x27;Widowed&#x27; , &#x27;marital-status&#x27;] = &#x27;Widowed&#x27;dataset_bin[&#x27;marital-status&#x27;] = dataset_raw[&#x27;marital-status&#x27;]dataset_con[&#x27;marital-status&#x27;] = dataset_raw[&#x27;marital-status&#x27;] 123plt.style.use(&#x27;seaborn-whitegrid&#x27;)fig = plt.figure(figsize=(20,3)) sns.countplot(y=&quot;marital-status&quot;, data=dataset_bin); Feature: Final Weight123# Let&#x27;s use the Pandas Cut function to bin the data in equally sized bucketsdataset_bin[&#x27;fnlwgt&#x27;] = pd.cut(dataset_raw[&#x27;fnlwgt&#x27;], 10)dataset_con[&#x27;fnlwgt&#x27;] = dataset_raw[&#x27;fnlwgt&#x27;] 123plt.style.use(&#x27;seaborn-whitegrid&#x27;)fig = plt.figure(figsize=(20,4)) sns.countplot(y=&quot;fnlwgt&quot;, data=dataset_bin); Feature: Education Number1234567# Let&#x27;s use the Pandas Cut function to bin the data in equally sized bucketsdataset_bin[&#x27;education-num&#x27;] = pd.cut(dataset_raw[&#x27;education-num&#x27;], 10)dataset_con[&#x27;education-num&#x27;] = dataset_raw[&#x27;education-num&#x27;]plt.style.use(&#x27;seaborn-whitegrid&#x27;)fig = plt.figure(figsize=(20,5)) sns.countplot(y=&quot;education-num&quot;, data=dataset_bin); Feature: Hours per Week12345678910# Let&#x27;s use the Pandas Cut function to bin the data in equally sized bucketsdataset_bin[&#x27;hours-per-week&#x27;] = pd.cut(dataset_raw[&#x27;hours-per-week&#x27;], 10)dataset_con[&#x27;hours-per-week&#x27;] = dataset_raw[&#x27;hours-per-week&#x27;]plt.style.use(&#x27;seaborn-whitegrid&#x27;)fig = plt.figure(figsize=(20,4)) plt.subplot(1, 2, 1)sns.countplot(y=&quot;hours-per-week&quot;, data=dataset_bin);plt.subplot(1, 2, 2)sns.distplot(dataset_con[&#x27;hours-per-week&#x27;]); Feature: Capital Gain12345678910# Let&#x27;s use the Pandas Cut function to bin the data in equally sized bucketsdataset_bin[&#x27;capital-gain&#x27;] = pd.cut(dataset_raw[&#x27;capital-gain&#x27;], 5)dataset_con[&#x27;capital-gain&#x27;] = dataset_raw[&#x27;capital-gain&#x27;]plt.style.use(&#x27;seaborn-whitegrid&#x27;)fig = plt.figure(figsize=(20,3)) plt.subplot(1, 2, 1)sns.countplot(y=&quot;capital-gain&quot;, data=dataset_bin);plt.subplot(1, 2, 2)sns.distplot(dataset_con[&#x27;capital-gain&#x27;]); Feature: Capital Loss12345678910# Let&#x27;s use the Pandas Cut function to bin the data in equally sized bucketsdataset_bin[&#x27;capital-loss&#x27;] = pd.cut(dataset_raw[&#x27;capital-loss&#x27;], 5)dataset_con[&#x27;capital-loss&#x27;] = dataset_raw[&#x27;capital-loss&#x27;]plt.style.use(&#x27;seaborn-whitegrid&#x27;)fig = plt.figure(figsize=(20,3)) plt.subplot(1, 2, 1)sns.countplot(y=&quot;capital-loss&quot;, data=dataset_bin);plt.subplot(1, 2, 2)sns.distplot(dataset_con[&#x27;capital-loss&#x27;]); Features: Race, Sex, Relationship1234# Some features we&#x27;ll consider to be in good enough shape as to pass throughdataset_con[&#x27;sex&#x27;] = dataset_bin[&#x27;sex&#x27;] = dataset_raw[&#x27;sex&#x27;]dataset_con[&#x27;race&#x27;] = dataset_bin[&#x27;race&#x27;] = dataset_raw[&#x27;race&#x27;]dataset_con[&#x27;relationship&#x27;] = dataset_bin[&#x27;relationship&#x27;] = dataset_raw[&#x27;relationship&#x27;] Bi-variate AnalysisSo far, we have analised all features individually. Let’s now start combining some of these features together to obtain further insight into the interactions between them. 12345678910111213141516# Plot a count of the categories from each categorical feature split by our prediction class: salary - predclass.def plot_bivariate_bar(dataset, hue, cols=5, width=20, height=15, hspace=0.2, wspace=0.5): dataset = dataset.select_dtypes(include=[np.object]) plt.style.use(&#x27;seaborn-whitegrid&#x27;) fig = plt.figure(figsize=(width,height)) fig.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=wspace, hspace=hspace) rows = math.ceil(float(dataset.shape[1]) / cols) for i, column in enumerate(dataset.columns): ax = fig.add_subplot(rows, cols, i + 1) ax.set_title(column) if dataset.dtypes[column] == np.object: g = sns.countplot(y=column, hue=hue, data=dataset) substrings = [s.get_text()[:10] for s in g.get_yticklabels()] g.set(yticklabels=substrings) plot_bivariate_bar(dataset_con, hue=&#x27;predclass&#x27;, cols=3, width=20, height=12, hspace=0.4, wspace=0.5) 1234# Effect of Marital Status and Education on Income, across Marital Status.plt.style.use(&#x27;seaborn-whitegrid&#x27;)g = sns.FacetGrid(dataset_con, col=&#x27;marital-status&#x27;, size=4, aspect=.7)g = g.map(sns.boxplot, &#x27;predclass&#x27;, &#x27;education-num&#x27;) 1234567891011# Historical Trends on the Sex, Education, HPW and Age impact on Income.plt.style.use(&#x27;seaborn-whitegrid&#x27;)fig = plt.figure(figsize=(20,4)) plt.subplot(1, 3, 1)sns.violinplot(x=&#x27;sex&#x27;, y=&#x27;education-num&#x27;, hue=&#x27;predclass&#x27;, data=dataset_con, split=True, scale=&#x27;count&#x27;);plt.subplot(1, 3, 2)sns.violinplot(x=&#x27;sex&#x27;, y=&#x27;hours-per-week&#x27;, hue=&#x27;predclass&#x27;, data=dataset_con, split=True, scale=&#x27;count&#x27;);plt.subplot(1, 3, 3)sns.violinplot(x=&#x27;sex&#x27;, y=&#x27;age&#x27;, hue=&#x27;predclass&#x27;, data=dataset_con, split=True, scale=&#x27;count&#x27;); 12345# Interaction between pairs of features.sns.pairplot(dataset_con[[&#x27;age&#x27;,&#x27;education-num&#x27;,&#x27;hours-per-week&#x27;,&#x27;predclass&#x27;,&#x27;capital-gain&#x27;,&#x27;capital-loss&#x27;]], hue=&quot;predclass&quot;, diag_kind=&quot;kde&quot;, size=4); Feature Crossing: Age + Hours Per WeekSo far, we have modified and cleaned features that existed in our dataset. However, we can go further and create a new new variables, adding human knowledge on the interaction between features. 12345678910111213# Crossing Numerical Featuresdataset_con[&#x27;age-hours&#x27;] = dataset_con[&#x27;age&#x27;] * dataset_con[&#x27;hours-per-week&#x27;]dataset_bin[&#x27;age-hours&#x27;] = pd.cut(dataset_con[&#x27;age-hours&#x27;], 10)dataset_con[&#x27;age-hours&#x27;] = dataset_con[&#x27;age-hours&#x27;]plt.style.use(&#x27;seaborn-whitegrid&#x27;)fig = plt.figure(figsize=(20,5)) plt.subplot(1, 2, 1)sns.countplot(y=&quot;age-hours&quot;, data=dataset_bin);plt.subplot(1, 2, 2)sns.distplot(dataset_con.loc[dataset_con[&#x27;predclass&#x27;] == 1][&#x27;age-hours&#x27;], kde_kws=&#123;&quot;label&quot;: &quot;&gt;$50K&quot;&#125;);sns.distplot(dataset_con.loc[dataset_con[&#x27;predclass&#x27;] == 0][&#x27;age-hours&#x27;], kde_kws=&#123;&quot;label&quot;: &quot;&lt;$50K&quot;&#125;); 123456# Crossing Categorical Featuresdataset_bin[&#x27;sex-marital&#x27;] = dataset_con[&#x27;sex-marital&#x27;] = dataset_con[&#x27;sex&#x27;] + dataset_con[&#x27;marital-status&#x27;]plt.style.use(&#x27;seaborn-whitegrid&#x27;)fig = plt.figure(figsize=(20,5)) sns.countplot(y=&quot;sex-marital&quot;, data=dataset_bin); Feature EncodingRemember that Machine Learning algorithms perform Linear Algebra on Matrices, which means all features need have numeric values. The process of converting Categorical Features into values is called Encoding. Here only perform One-Hot but not Label encoding. Additional Resources: http://pbpython.com/categorical-encoding.html 123456# One Hot Encodes all labels before Machine Learningone_hot_cols = dataset_bin.columns.tolist()one_hot_cols.remove(&#x27;predclass&#x27;)dataset_bin_enc = pd.get_dummies(dataset_bin, columns=one_hot_cols)dataset_bin_enc.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; predclass age_(16.927, 24.3] age_(24.3, 31.6] age_(31.6, 38.9] age_(38.9, 46.2] age_(46.2, 53.5] age_(53.5, 60.8] age_(60.8, 68.1] age_(68.1, 75.4] age_(75.4, 82.7] ... sex-marital_FemaleMarried sex-marital_FemaleNever-Married sex-marital_FemaleNot-Married sex-marital_FemaleSeparated sex-marital_FemaleWidowed sex-marital_MaleMarried sex-marital_MaleNever-Married sex-marital_MaleNot-Married sex-marital_MaleSeparated sex-marital_MaleWidowed 0 0 0 0 0 1 0 0 0 0 0 ... 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 1 0 0 0 0 ... 0 0 0 0 0 1 0 0 0 0 2 0 0 0 1 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 1 0 3 0 0 0 0 0 1 0 0 0 0 ... 0 0 0 0 0 1 0 0 0 0 4 0 0 1 0 0 0 0 0 0 0 ... 1 0 0 0 0 0 0 0 0 0 5 rows × 116 columns 1234567891011121314151617# &#x27;dataset_con&#x27; is original input dataset for this section# build a new dataframe containing only the object columns#obj_df = dataset_con.select_dtypes(include=[&#x27;object&#x27;]).copy()#obj_df.head()# use dropna() delete NaN rows#obj_df = obj_df.dropna(axis=0)# use most prevailing value to fill in the null values# (Private -&gt; NaN workclass)#obj_df[obj_df.isnull().any(axis=1)]#obj_df[&quot;workclass&quot;].value_counts()#obj_df = obj_df.fillna(&#123;&quot;workclass&quot;: &quot;Private&quot;&#125;) 1#dataset_con.dtypes 1234# delete the rows contains NaN valuesdataset_con_enc = dataset_con.dropna(axis=0)print(dataset_con_enc)dataset_con_enc[dataset_con_enc.isnull().any(axis=1)] predclass age workclass occupation native-country education \\ 0 0 39 Non-fed-gov Admin United-States Bachelors 1 0 50 Self-emp Office Labour United-States Bachelors 2 0 38 Private Manual Labour United-States HS-grad 3 0 53 Private Manual Labour United-States Dropout 4 0 28 Private Professional South-America Bachelors ... ... ... ... ... ... ... 48836 0 33 Private Professional United-States Bachelors 48837 0 39 Private Professional United-States Bachelors 48839 0 38 Private Professional United-States Bachelors 48840 0 44 Private Admin United-States Bachelors 48841 1 35 Self-emp Office Labour United-States Bachelors marital-status fnlwgt education-num hours-per-week capital-gain \\ 0 Never-Married 77516 13 40 2174 1 Married 83311 13 13 0 2 Separated 215646 9 40 0 3 Married 234721 7 40 0 4 Married 338409 13 40 0 ... ... ... ... ... ... 48836 Never-Married 245211 13 40 0 48837 Separated 215419 13 36 0 48839 Married 374983 13 50 0 48840 Separated 83891 13 40 5455 48841 Married 182148 13 60 0 capital-loss sex race relationship age-hours \\ 0 0 Male White Not-in-family 1560 1 0 Male White Husband 650 2 0 Male White Not-in-family 1520 3 0 Male Black Husband 2120 4 0 Female Black Wife 1120 ... ... ... ... ... ... 48836 0 Male White Own-child 1320 48837 0 Female White Not-in-family 1404 48839 0 Male White Husband 1900 48840 0 Male Asian-Pac-Islander Own-child 1760 48841 0 Male White Husband 2100 sex-marital 0 MaleNever-Married 1 MaleMarried 2 MaleSeparated 3 MaleMarried 4 FemaleMarried ... ... 48836 MaleNever-Married 48837 FemaleSeparated 48839 MaleMarried 48840 MaleSeparated 48841 MaleMarried [45222 rows x 17 columns] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; predclass age workclass occupation native-country education marital-status fnlwgt education-num hours-per-week capital-gain capital-loss sex race relationship age-hours sex-marital 12345# Label Encode all labelsle = preprocessing.LabelEncoder()dataset_con_enc = dataset_con_enc.apply(le.fit_transform)dataset_con_enc.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; predclass age workclass occupation native-country education marital-status fnlwgt education-num hours-per-week capital-gain capital-loss sex race relationship age-hours sex-marital 0 0 22 1 0 7 1 1 3217 12 39 26 0 1 4 1 655 6 1 0 33 4 3 7 1 0 3519 12 12 0 0 1 4 0 302 5 2 0 21 3 1 7 5 3 17196 8 39 0 0 1 4 1 644 8 3 0 36 3 1 7 3 0 18738 6 39 0 0 1 2 0 847 5 4 0 11 3 4 6 1 0 23828 12 39 0 0 0 2 5 494 0 Feature Reduction / SelectionOnce we have our features ready to use, we might find that the number of features available is too large to be run in a reasonable timeframe by our machine learning algorithms. There’s a number of options available to us for feature reduction and feature selection. Dimensionality Reduction: Principal Component Analysis (PCA): Principal component analysis (PCA) is a statistical procedure that uses an orthogonal transformation to convert a set of observations of possibly correlated variables into a set of values of linearly uncorrelated variables called principal components. This transformation is defined in such a way that the first principal component has the largest possible variance (that is, accounts for as much of the variability in the data as possible), and each succeeding component in turn has the highest variance possible under the constraint that it is orthogonal to the preceding components. Singular Value Decomposition (SVD): SVD is a factorization of a real or complex matrix. It is the generalization of the eigendecomposition of a positive semidefinite normal matrix (for example, a symmetric matrix with positive eigenvalues) to any m×n matrix via an extension of the polar decomposition. It has many useful applications in signal processing and statistics. Feature Importance/Relevance: Filter Methods: Filter type methods select features based only on general metrics like the correlation with the variable to predict. Filter methods suppress the least interesting variables. The other variables will be part of a classification or a regression model used to classify or to predict data. These methods are particularly effective in computation time and robust to overfitting. Wrapper Methods: Wrapper methods evaluate subsets of variables which allows, unlike filter approaches, to detect the possible interactions between variables. The two main disadvantages of these methods are : The increasing overfitting risk when the number of observations is insufficient. AND. The significant computation time when the number of variables is large. Embedded Methods: Embedded methods try to combine the advantages of both previous methods. A learning algorithm takes advantage of its own variable selection process and performs feature selection and classification simultaneously. Feature CorrelationCorrelation ia s measure of how much two random variables change together. Features should be uncorrelated with each other and highly correlated to the feature we’re trying to predict. 123456789101112131415161718192021222324# Create a correlation plot of both datasets.plt.style.use(&#x27;seaborn-whitegrid&#x27;)fig = plt.figure(figsize=(25,10)) plt.subplot(1, 2, 1)# Generate a mask for the upper trianglemask = np.zeros_like(dataset_bin_enc.corr(), dtype=np.bool)mask[np.triu_indices_from(mask)] = Truesns.heatmap(dataset_bin_enc.corr(), vmin=-1, vmax=1, square=True, cmap=sns.color_palette(&quot;RdBu_r&quot;, 100), mask=mask, linewidths=.5);plt.subplot(1, 2, 2)mask = np.zeros_like(dataset_con_enc.corr(), dtype=np.bool)mask[np.triu_indices_from(mask)] = Truesns.heatmap(dataset_con_enc.corr(), vmin=-1, vmax=1, square=True, cmap=sns.color_palette(&quot;RdBu_r&quot;, 100), mask=mask, linewidths=.5); Feature ImportanceRandom forest consists of a number of decision trees. Every node in the decision trees is a condition on a single feature, designed to split the dataset into two so that similar response values end up in the same set. The measure based on which the (locally) optimal condition is chosen is called impurity. When training a tree, it can be computed how much each feature decreases the weighted impurity in a tree. For a forest, the impurity decrease from each feature can be averaged and the features are ranked according to this measure. This is the feature importance measure exposed in sklearn’s Random Forest implementations. 12345678# Using Random Forest to gain an insight on Feature Importanceclf = RandomForestClassifier()clf.fit(dataset_con_enc.drop(&#x27;predclass&#x27;, axis=1), dataset_con_enc[&#x27;predclass&#x27;])plt.style.use(&#x27;seaborn-whitegrid&#x27;)importance = clf.feature_importances_importance = pd.DataFrame(importance, index=dataset_con_enc.drop(&#x27;predclass&#x27;, axis=1).columns, columns=[&quot;Importance&quot;])importance.sort_values(by=&#x27;Importance&#x27;, ascending=True).plot(kind=&#x27;barh&#x27;, figsize=(20,len(importance)/2)); PCAPrincipal component analysis (PCA) is a statistical procedure that uses an orthogonal transformation to convert a set of observations of possibly correlated variables into a set of values of linearly uncorrelated variables called principal components. This transformation is defined in such a way that the first principal component has the largest possible variance (that is, accounts for as much of the variability in the data as possible), and each succeeding component in turn has the highest variance possible under the constraint that it is orthogonal to the preceding components. We can use PCA to reduce the number of features to use in our ML algorithms, and graphing the variance gives us an idea of how many features we really need to represent our dataset fully. 1234567891011121314151617181920212223242526# Calculating PCA for both datasets, and graphing the Variance for each feature, per datasetstd_scale = preprocessing.StandardScaler().fit(dataset_bin_enc.drop(&#x27;predclass&#x27;, axis=1))X = std_scale.transform(dataset_bin_enc.drop(&#x27;predclass&#x27;, axis=1))pca1 = PCA(n_components=len(dataset_bin_enc.columns)-1)fit1 = pca1.fit(X)std_scale = preprocessing.StandardScaler().fit(dataset_con_enc.drop(&#x27;predclass&#x27;, axis=1))X = std_scale.transform(dataset_con_enc.drop(&#x27;predclass&#x27;, axis=1))pca2 = PCA(n_components=len(dataset_con_enc.columns)-2)fit2 = pca2.fit(X)# Graphing the variance per featureplt.style.use(&#x27;seaborn-whitegrid&#x27;)plt.figure(figsize=(25,7)) plt.subplot(1, 2, 1)plt.xlabel(&#x27;PCA Feature&#x27;)plt.ylabel(&#x27;Variance&#x27;)plt.title(&#x27;PCA for Discretised Dataset&#x27;)plt.bar(range(0, fit1.explained_variance_ratio_.size), fit1.explained_variance_ratio_);plt.subplot(1, 2, 2)plt.xlabel(&#x27;PCA Feature&#x27;)plt.ylabel(&#x27;Variance&#x27;)plt.title(&#x27;PCA for Continuous Dataset&#x27;)plt.bar(range(0, fit2.explained_variance_ratio_.size), fit2.explained_variance_ratio_); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# PCA&#x27;s components graphed in 2D and 3D# Apply Scaling std_scale = preprocessing.StandardScaler().fit(dataset_con_enc.drop(&#x27;predclass&#x27;, axis=1))X = std_scale.transform(dataset_con_enc.drop(&#x27;predclass&#x27;, axis=1))y = dataset_con_enc[&#x27;predclass&#x27;]# Formattingtarget_names = [0,1]colors = [&#x27;navy&#x27;,&#x27;darkorange&#x27;]lw = 2alpha = 0.3# 2 Components PCAplt.style.use(&#x27;seaborn-whitegrid&#x27;)plt.figure(2, figsize=(20, 8))plt.subplot(1, 2, 1)pca = PCA(n_components=2)X_r = pca.fit(X).transform(X)for color, i, target_name in zip(colors, [0, 1], target_names): plt.scatter(X_r[y == i, 0], X_r[y == i, 1], color=color, alpha=alpha, lw=lw, label=target_name)plt.legend(loc=&#x27;best&#x27;, shadow=False, scatterpoints=1)plt.title(&#x27;First two PCA directions&#x27;);# 3 Components PCAax = plt.subplot(1, 2, 2, projection=&#x27;3d&#x27;)pca = PCA(n_components=3)X_reduced = pca.fit(X).transform(X)for color, i, target_name in zip(colors, [0, 1], target_names): ax.scatter(X_reduced[y == i, 0], X_reduced[y == i, 1], X_reduced[y == i, 2], color=color, alpha=alpha, lw=lw, label=target_name)plt.legend(loc=&#x27;best&#x27;, shadow=False, scatterpoints=1)ax.set_title(&quot;First three PCA directions&quot;)ax.set_xlabel(&quot;1st eigenvector&quot;)ax.set_ylabel(&quot;2nd eigenvector&quot;)ax.set_zlabel(&quot;3rd eigenvector&quot;)# rotate the axesax.view_init(30, 10) Recursive Feature EliminationFeature ranking with recursive feature elimination and cross-validated selection of the best number of features. 1234567891011121314# Calculating RFE for non-discretised dataset, and graphing the Importance for each feature, per datasetselector1 = RFECV(LogisticRegression(), step=1, cv=5, n_jobs=-1)selector1 = selector1.fit(dataset_con_enc.drop(&#x27;predclass&#x27;, axis=1).values, dataset_con_enc[&#x27;predclass&#x27;].values)print(&quot;Feature Ranking For Non-Discretised: %s&quot; % selector1.ranking_)print(&quot;Optimal number of features : %d&quot; % selector1.n_features_)# Plot number of features VS. cross-validation scoresplt.style.use(&#x27;seaborn-whitegrid&#x27;)plt.figure(figsize=(20,5)) plt.xlabel(&quot;Number of features selected - Non-Discretised&quot;)plt.ylabel(&quot;Cross validation score (nb of correct classifications)&quot;)plt.plot(range(1, len(selector1.grid_scores_) + 1), selector1.grid_scores_);# Feature space could be subsetted like so:dataset_con_enc = dataset_con_enc[dataset_con_enc.columns[np.insert(selector1.support_, 0, True)]] Feature Ranking For Non-Discretised: [1 1 1 1 3 1 4 1 1 1 1 1 1 1 2 1] Optimal number of features : 13 Selecting DatasetWe now have two datasets to choose from to apply our ML algorithms. The one-hot-encoded, and the label-encoded. For now, we have decided not to use feature reduction or selection algorithms. 1234567# OPTIONS: # - dataset_bin_enc# - dataset_con_enc# Change the dataset to test how would the algorithms perform under a differently encoded dataset.selected_dataset = dataset_bin_enc 1selected_dataset.head(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; predclass age_(16.927, 24.3] age_(24.3, 31.6] age_(31.6, 38.9] age_(38.9, 46.2] age_(46.2, 53.5] age_(53.5, 60.8] age_(60.8, 68.1] age_(68.1, 75.4] age_(75.4, 82.7] ... sex-marital_FemaleMarried sex-marital_FemaleNever-Married sex-marital_FemaleNot-Married sex-marital_FemaleSeparated sex-marital_FemaleWidowed sex-marital_MaleMarried sex-marital_MaleNever-Married sex-marital_MaleNot-Married sex-marital_MaleSeparated sex-marital_MaleWidowed 0 0 0 0 0 1 0 0 0 0 0 ... 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 1 0 0 0 0 ... 0 0 0 0 0 1 0 0 0 0 2 rows × 116 columns Splitting Data into Training and Testing DatasetsWe need to split the data back into the training and testing datasets. Remember we joined both right at the beginning. 123# Splitting the Training and Test data setstrain = selected_dataset.loc[0:32560,:]test = selected_dataset.loc[32560:,:] Removing Samples with Missing dataWe could have removed rows with missing data during feature cleaning, but we’re choosing to do it at this point. It’s easier to do it this way, right after we split the data into Training and Testing. Otherwise we would have had to keep track of the number of deleted rows in our data and take that into account when deciding on a splitting boundary for our joined data. 1234# Given missing fields are a small percentange of the overall dataset, # we have chosen to delete them.train = train.dropna(axis=0)test = test.dropna(axis=0) Rename datasets before Machine Learning algos12345X_train_w_label = trainX_train = train.drop([&#x27;predclass&#x27;], axis=1)y_train = train[&#x27;predclass&#x27;].astype(&#x27;int64&#x27;)X_test = test.drop([&#x27;predclass&#x27;], axis=1)y_test = test[&#x27;predclass&#x27;].astype(&#x27;int64&#x27;) Machine Learning AlgorithmsData ReviewLet’s take one last peek at our data before we start running the Machine Learning algorithms. 1X_train.shape (32561, 115) 1X_train.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; age_(16.927, 24.3] age_(24.3, 31.6] age_(31.6, 38.9] age_(38.9, 46.2] age_(46.2, 53.5] age_(53.5, 60.8] age_(60.8, 68.1] age_(68.1, 75.4] age_(75.4, 82.7] age_(82.7, 90.0] ... sex-marital_FemaleMarried sex-marital_FemaleNever-Married sex-marital_FemaleNot-Married sex-marital_FemaleSeparated sex-marital_FemaleWidowed sex-marital_MaleMarried sex-marital_MaleNever-Married sex-marital_MaleNot-Married sex-marital_MaleSeparated sex-marital_MaleWidowed 0 0 0 0 1 0 0 0 0 0 0 ... 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 1 0 0 0 0 0 ... 0 0 0 0 0 1 0 0 0 0 2 0 0 1 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 1 0 3 0 0 0 0 1 0 0 0 0 0 ... 0 0 0 0 0 1 0 0 0 0 4 0 1 0 0 0 0 0 0 0 0 ... 1 0 0 0 0 0 0 0 0 0 5 rows × 115 columns 1y_train.head() 0 0 1 0 2 0 3 0 4 0 Name: predclass, dtype: int64 123# Setting a random seed will guarantee we get the same results # every time we run our training and testing.random.seed(1) AlgorithmsFrom here, we will be running the following algorithms. KNN Logistic Regression Random Forest Naive Bayes Stochastic Gradient Decent Linear SVC Decision Tree Gradient Boosted Trees Because there’s a great deal of repetitiveness on the code for each, we’ll create a custom function to analyse this. For some algorithms, we have also chosen to run a Random Hyperparameter search, to select the best hyperparameters for a given algorithm. 12345678910111213# calculate the fpr and tpr for all thresholds of the classificationdef plot_roc_curve(y_test, preds): fpr, tpr, threshold = metrics.roc_curve(y_test, preds) roc_auc = metrics.auc(fpr, tpr) plt.title(&#x27;Receiver Operating Characteristic&#x27;) plt.plot(fpr, tpr, &#x27;b&#x27;, label = &#x27;AUC = %0.2f&#x27; % roc_auc) plt.legend(loc = &#x27;lower right&#x27;) plt.plot([0, 1], [0, 1],&#x27;r--&#x27;) plt.xlim([-0.01, 1.01]) plt.ylim([-0.01, 1.01]) plt.ylabel(&#x27;True Positive Rate&#x27;) plt.xlabel(&#x27;False Positive Rate&#x27;) plt.show() 1234567891011121314151617181920212223# Function that runs the requested algorithm and returns the accuracy metricsdef fit_ml_algo(algo, X_train, y_train, X_test, cv): # One Pass model = algo.fit(X_train, y_train) test_pred = model.predict(X_test) if (isinstance(algo, (LogisticRegression, KNeighborsClassifier, GaussianNB, DecisionTreeClassifier, RandomForestClassifier, GradientBoostingClassifier))): probs = model.predict_proba(X_test)[:,1] else: probs = &quot;Not Available&quot; acc = round(model.score(X_test, y_test) * 100, 2) # CV train_pred = model_selection.cross_val_predict(algo, X_train, y_train, cv=cv, n_jobs = -1) acc_cv = round(metrics.accuracy_score(y_train, train_pred) * 100, 2) return train_pred, test_pred, acc, acc_cv, probs 123456789101112131415161718192021222324252627282930313233# Logistic Regression - Random Search for Hyperparameters# Utility function to report best scoresdef report(results, n_top=5): for i in range(1, n_top + 1): candidates = np.flatnonzero(results[&#x27;rank_test_score&#x27;] == i) for candidate in candidates: print(&quot;Model with rank: &#123;0&#125;&quot;.format(i)) print(&quot;Mean validation score: &#123;0:.3f&#125; (std: &#123;1:.3f&#125;)&quot;.format( results[&#x27;mean_test_score&#x27;][candidate], results[&#x27;std_test_score&#x27;][candidate])) print(&quot;Parameters: &#123;0&#125;&quot;.format(results[&#x27;params&#x27;][candidate])) print(&quot;&quot;) # Specify parameters and distributions to sample fromparam_dist = &#123;&#x27;penalty&#x27;: [&#x27;l2&#x27;, &#x27;l1&#x27;], &#x27;class_weight&#x27;: [None, &#x27;balanced&#x27;], &#x27;C&#x27;: np.logspace(-20, 20, 10000), &#x27;intercept_scaling&#x27;: np.logspace(-20, 20, 10000)&#125;# Run Randomized Searchn_iter_search = 10lrc = LogisticRegression()random_search = RandomizedSearchCV(lrc, n_jobs=-1, param_distributions=param_dist, n_iter=n_iter_search)start = time.time()random_search.fit(X_train, y_train)print(&quot;RandomizedSearchCV took %.2f seconds for %d candidates&quot; &quot; parameter settings.&quot; % ((time.time() - start), n_iter_search))report(random_search.cv_results_) RandomizedSearchCV took 6.84 seconds for 10 candidates parameter settings. Model with rank: 1 Mean validation score: 0.844 (std: 0.004) Parameters: &#123;&#39;penalty&#39;: &#39;l2&#39;, &#39;intercept_scaling&#39;: 42370413880.09742, &#39;class_weight&#39;: None, &#39;C&#39;: 6.248554728170629e+17&#125; Model with rank: 2 Mean validation score: 0.800 (std: 0.004) Parameters: &#123;&#39;penalty&#39;: &#39;l2&#39;, &#39;intercept_scaling&#39;: 5.356398592977186e-12, &#39;class_weight&#39;: &#39;balanced&#39;, &#39;C&#39;: 318529980510.9508&#125; Model with rank: 2 Mean validation score: 0.800 (std: 0.004) Parameters: &#123;&#39;penalty&#39;: &#39;l2&#39;, &#39;intercept_scaling&#39;: 6.741908876164404e-13, &#39;class_weight&#39;: &#39;balanced&#39;, &#39;C&#39;: 1.753171420878381e+18&#125; Model with rank: 4 Mean validation score: 0.800 (std: 0.004) Parameters: &#123;&#39;penalty&#39;: &#39;l2&#39;, &#39;intercept_scaling&#39;: 0.03646331805309427, &#39;class_weight&#39;: &#39;balanced&#39;, &#39;C&#39;: 431085.5408791511&#125; Model with rank: 5 Mean validation score: 0.759 (std: 0.000) Parameters: &#123;&#39;penalty&#39;: &#39;l2&#39;, &#39;intercept_scaling&#39;: 52853324182.66478, &#39;class_weight&#39;: None, &#39;C&#39;: 3.311707756163145e-20&#125; 1234567891011# Logistic Regressionstart_time = time.time()train_pred_log, test_pred_log, acc_log, acc_cv_log, probs_log = fit_ml_algo(LogisticRegression(n_jobs = -1), X_train, y_train, X_test, 10)log_time = (time.time() - start_time)print(&quot;Accuracy: %s&quot; % acc_log)print(&quot;Accuracy CV 10-Fold: %s&quot; % acc_cv_log)print(&quot;Running Time: %s&quot; % datetime.timedelta(seconds=log_time)) Accuracy: 84.47 Accuracy CV 10-Fold: 84.33 Running Time: 0:00:09.857440 1print(metrics.confusion_matrix(y_test, test_pred_log)) [[11501 934] [ 1595 2252]] 1print(metrics.classification_report(y_train, train_pred_log)) precision recall f1-score support 0 0.88 0.93 0.90 24720 1 0.71 0.58 0.64 7841 accuracy 0.84 32561 macro avg 0.79 0.75 0.77 32561 weighted avg 0.84 0.84 0.84 32561 1print(metrics.classification_report(y_test, test_pred_log)) precision recall f1-score support 0 0.88 0.92 0.90 12435 1 0.71 0.59 0.64 3847 accuracy 0.84 16282 macro avg 0.79 0.76 0.77 16282 weighted avg 0.84 0.84 0.84 16282 1plot_roc_curve(y_test, probs_log) 123456789101112# k-Nearest Neighborsstart_time = time.time()train_pred_knn, test_pred_knn, acc_knn, acc_cv_knn, probs_knn = fit_ml_algo(KNeighborsClassifier(n_neighbors = 3, n_jobs = -1), X_train, y_train, X_test, 10)knn_time = (time.time() - start_time)print(&quot;Accuracy: %s&quot; % acc_knn)print(&quot;Accuracy CV 10-Fold: %s&quot; % acc_cv_knn)print(&quot;Running Time: %s&quot; % datetime.timedelta(seconds=knn_time)) Accuracy: 81.02 Accuracy CV 10-Fold: 81.13 Running Time: 0:02:21.181324 1print(metrics.classification_report(y_train, train_pred_knn)) precision recall f1-score support 0 0.86 0.89 0.88 24720 1 0.62 0.56 0.59 7841 accuracy 0.81 32561 macro avg 0.74 0.73 0.73 32561 weighted avg 0.81 0.81 0.81 32561 1print(metrics.classification_report(y_test, test_pred_knn)) precision recall f1-score support 0 0.87 0.89 0.88 12435 1 0.61 0.56 0.58 3847 accuracy 0.81 16282 macro avg 0.74 0.72 0.73 16282 weighted avg 0.81 0.81 0.81 16282 1plot_roc_curve(y_test, probs_knn) 1234567891011# Gaussian Naive Bayesstart_time = time.time()train_pred_gaussian, test_pred_gaussian, acc_gaussian, acc_cv_gaussian, probs_gau = fit_ml_algo(GaussianNB(), X_train, y_train, X_test, 10)gaussian_time = (time.time() - start_time)print(&quot;Accuracy: %s&quot; % acc_gaussian)print(&quot;Accuracy CV 10-Fold: %s&quot; % acc_cv_gaussian)print(&quot;Running Time: %s&quot; % datetime.timedelta(seconds=gaussian_time)) Accuracy: 75.59 Accuracy CV 10-Fold: 74.51 Running Time: 0:00:00.479271 1print(metrics.classification_report(y_train, train_pred_gaussian)) precision recall f1-score support 0 0.95 0.70 0.81 24720 1 0.48 0.88 0.62 7841 accuracy 0.75 32561 macro avg 0.72 0.79 0.72 32561 weighted avg 0.84 0.75 0.76 32561 1print(metrics.classification_report(y_test, test_pred_gaussian)) precision recall f1-score support 0 0.94 0.72 0.82 12435 1 0.49 0.86 0.63 3847 accuracy 0.76 16282 macro avg 0.72 0.79 0.72 16282 weighted avg 0.84 0.76 0.77 16282 1plot_roc_curve(y_test, probs_gau) 1234567891011# Linear SVCstart_time = time.time()train_pred_svc, test_pred_svc, acc_linear_svc, acc_cv_linear_svc, _ = fit_ml_algo(LinearSVC(), X_train, y_train, X_test, 10)linear_svc_time = (time.time() - start_time)print(&quot;Accuracy: %s&quot; % acc_linear_svc)print(&quot;Accuracy CV 10-Fold: %s&quot; % acc_cv_linear_svc)print(&quot;Running Time: %s&quot; % datetime.timedelta(seconds=linear_svc_time)) Accuracy: 84.42 Accuracy CV 10-Fold: 84.46 Running Time: 0:00:07.630441 1print(metrics.classification_report(y_train, train_pred_svc)) precision recall f1-score support 0 0.88 0.93 0.90 24720 1 0.72 0.58 0.64 7841 accuracy 0.84 32561 macro avg 0.80 0.76 0.77 32561 weighted avg 0.84 0.84 0.84 32561 1print(metrics.classification_report(y_test, test_pred_svc)) precision recall f1-score support 0 0.88 0.93 0.90 12435 1 0.71 0.58 0.64 3847 accuracy 0.84 16282 macro avg 0.79 0.75 0.77 16282 weighted avg 0.84 0.84 0.84 16282 1234567891011# Stochastic Gradient Descentstart_time = time.time()train_pred_sgd, test_pred_sgd, acc_sgd, acc_cv_sgd, _ = fit_ml_algo(SGDClassifier(n_jobs = -1), X_train, y_train, X_test, 10)sgd_time = (time.time() - start_time)print(&quot;Accuracy: %s&quot; % acc_sgd)print(&quot;Accuracy CV 10-Fold: %s&quot; % acc_cv_sgd)print(&quot;Running Time: %s&quot; % datetime.timedelta(seconds=sgd_time)) Accuracy: 84.15 Accuracy CV 10-Fold: 83.74 Running Time: 0:00:02.039138 1print(metrics.classification_report(y_train, train_pred_sgd)) precision recall f1-score support 0 0.88 0.91 0.89 24720 1 0.69 0.60 0.64 7841 accuracy 0.84 32561 macro avg 0.78 0.76 0.77 32561 weighted avg 0.83 0.84 0.83 32561 1print(metrics.classification_report(y_test, test_pred_sgd)) precision recall f1-score support 0 0.88 0.91 0.90 12435 1 0.69 0.61 0.64 3847 accuracy 0.84 16282 macro avg 0.78 0.76 0.77 16282 weighted avg 0.84 0.84 0.84 16282 1234567891011# Decision Tree Classifierstart_time = time.time()train_pred_dt, test_pred_dt, acc_dt, acc_cv_dt, probs_dt = fit_ml_algo(DecisionTreeClassifier(), X_train, y_train, X_test, 10)dt_time = (time.time() - start_time)print(&quot;Accuracy: %s&quot; % acc_dt)print(&quot;Accuracy CV 10-Fold: %s&quot; % acc_cv_dt)print(&quot;Running Time: %s&quot; % datetime.timedelta(seconds=dt_time)) Accuracy: 79.93 Accuracy CV 10-Fold: 80.44 Running Time: 0:00:01.417276 1print(metrics.confusion_matrix(y_test, test_pred_dt)) [[10956 1479] [ 1788 2059]] 1print(metrics.classification_report(y_train, train_pred_dt)) precision recall f1-score support 0 0.86 0.89 0.87 24720 1 0.60 0.54 0.57 7841 accuracy 0.80 32561 macro avg 0.73 0.72 0.72 32561 weighted avg 0.80 0.80 0.80 32561 1print(metrics.classification_report(y_test, test_pred_dt)) precision recall f1-score support 0 0.86 0.88 0.87 12435 1 0.58 0.54 0.56 3847 accuracy 0.80 16282 macro avg 0.72 0.71 0.71 16282 weighted avg 0.79 0.80 0.80 16282 1plot_roc_curve(y_test, probs_dt) 1234567891011121314151617181920212223242526272829303132333435# Random Forest Classifier - Random Search for Hyperparameters# Utility function to report best scoresdef report(results, n_top=5): for i in range(1, n_top + 1): candidates = np.flatnonzero(results[&#x27;rank_test_score&#x27;] == i) for candidate in candidates: print(&quot;Model with rank: &#123;0&#125;&quot;.format(i)) print(&quot;Mean validation score: &#123;0:.3f&#125; (std: &#123;1:.3f&#125;)&quot;.format( results[&#x27;mean_test_score&#x27;][candidate], results[&#x27;std_test_score&#x27;][candidate])) print(&quot;Parameters: &#123;0&#125;&quot;.format(results[&#x27;params&#x27;][candidate])) print(&quot;&quot;) # Specify parameters and distributions to sample fromparam_dist = &#123;&quot;max_depth&quot;: [10, None], &quot;max_features&quot;: sp_randint(1, 11), &quot;min_samples_split&quot;: sp_randint(2, 20), &quot;min_samples_leaf&quot;: sp_randint(1, 11), &quot;bootstrap&quot;: [True, False], &quot;criterion&quot;: [&quot;gini&quot;, &quot;entropy&quot;]&#125;# Run Randomized Searchn_iter_search = 10rfc = RandomForestClassifier(n_estimators=10)random_search = RandomizedSearchCV(rfc, n_jobs = -1, param_distributions=param_dist, n_iter=n_iter_search)start = time.time()random_search.fit(X_train, y_train)print(&quot;RandomizedSearchCV took %.2f seconds for %d candidates&quot; &quot; parameter settings.&quot; % ((time.time() - start), n_iter_search))report(random_search.cv_results_) RandomizedSearchCV took 2.68 seconds for 10 candidates parameter settings. Model with rank: 1 Mean validation score: 0.839 (std: 0.004) Parameters: &#123;&#39;bootstrap&#39;: False, &#39;criterion&#39;: &#39;gini&#39;, &#39;max_depth&#39;: None, &#39;max_features&#39;: 4, &#39;min_samples_leaf&#39;: 2, &#39;min_samples_split&#39;: 13&#125; Model with rank: 2 Mean validation score: 0.838 (std: 0.005) Parameters: &#123;&#39;bootstrap&#39;: True, &#39;criterion&#39;: &#39;entropy&#39;, &#39;max_depth&#39;: None, &#39;max_features&#39;: 10, &#39;min_samples_leaf&#39;: 5, &#39;min_samples_split&#39;: 2&#125; Model with rank: 3 Mean validation score: 0.838 (std: 0.005) Parameters: &#123;&#39;bootstrap&#39;: False, &#39;criterion&#39;: &#39;entropy&#39;, &#39;max_depth&#39;: None, &#39;max_features&#39;: 7, &#39;min_samples_leaf&#39;: 9, &#39;min_samples_split&#39;: 4&#125; Model with rank: 4 Mean validation score: 0.838 (std: 0.004) Parameters: &#123;&#39;bootstrap&#39;: True, &#39;criterion&#39;: &#39;entropy&#39;, &#39;max_depth&#39;: 10, &#39;max_features&#39;: 10, &#39;min_samples_leaf&#39;: 2, &#39;min_samples_split&#39;: 13&#125; Model with rank: 5 Mean validation score: 0.834 (std: 0.004) Parameters: &#123;&#39;bootstrap&#39;: False, &#39;criterion&#39;: &#39;entropy&#39;, &#39;max_depth&#39;: 10, &#39;max_features&#39;: 7, &#39;min_samples_leaf&#39;: 5, &#39;min_samples_split&#39;: 2&#125; 12345678910111213141516# Random Forest Classifierstart_time = time.time()rfc = RandomForestClassifier(n_estimators=10, min_samples_leaf=2, min_samples_split=17, criterion=&#x27;gini&#x27;, max_features=8)train_pred_rf, test_pred_rf, acc_rf, acc_cv_rf, probs_rf = fit_ml_algo(rfc, X_train, y_train, X_test, 10)rf_time = (time.time() - start_time)print(&quot;Accuracy: %s&quot; % acc_rf)print(&quot;Accuracy CV 10-Fold: %s&quot; % acc_cv_rf)print(&quot;Running Time: %s&quot; % datetime.timedelta(seconds=rf_time)) Accuracy: 84.07 Accuracy CV 10-Fold: 84.05 Running Time: 0:00:01.423032 1print(metrics.classification_report(y_train, train_pred_rf)) precision recall f1-score support 0 0.87 0.93 0.90 24720 1 0.71 0.57 0.63 7841 accuracy 0.84 32561 macro avg 0.79 0.75 0.76 32561 weighted avg 0.83 0.84 0.83 32561 1print(metrics.classification_report(y_test, test_pred_rf)) precision recall f1-score support 0 0.87 0.93 0.90 12435 1 0.70 0.56 0.63 3847 accuracy 0.84 16282 macro avg 0.79 0.74 0.76 16282 weighted avg 0.83 0.84 0.83 16282 1plot_roc_curve(y_test, probs_rf) 1234567891011# Gradient Boosting Treesstart_time = time.time()train_pred_gbt, test_pred_gbt, acc_gbt, acc_cv_gbt, probs_gbt = fit_ml_algo(GradientBoostingClassifier(), X_train, y_train, X_test, 10)gbt_time = (time.time() - start_time)print(&quot;Accuracy: %s&quot; % acc_gbt)print(&quot;Accuracy CV 10-Fold: %s&quot; % acc_cv_gbt)print(&quot;Running Time: %s&quot; % datetime.timedelta(seconds=gbt_time)) Accuracy: 84.53 Accuracy CV 10-Fold: 84.34 Running Time: 0:00:18.993168 1print(metrics.classification_report(y_train, train_pred_gbt)) precision recall f1-score support 0 0.87 0.93 0.90 24720 1 0.72 0.57 0.64 7841 accuracy 0.84 32561 macro avg 0.80 0.75 0.77 32561 weighted avg 0.84 0.84 0.84 32561 1print(metrics.classification_report(y_test, test_pred_gbt)) precision recall f1-score support 0 0.88 0.93 0.90 12435 1 0.71 0.58 0.64 3847 accuracy 0.85 16282 macro avg 0.79 0.75 0.77 16282 weighted avg 0.84 0.85 0.84 16282 1plot_roc_curve(y_test, probs_gbt) Ranking ResultsLet’s rank the results for all the algorithms we have used 12345678910111213141516models = pd.DataFrame(&#123; &#x27;Model&#x27;: [&#x27;KNN&#x27;, &#x27;Logistic Regression&#x27;, &#x27;Random Forest&#x27;, &#x27;Naive Bayes&#x27;, &#x27;Stochastic Gradient Decent&#x27;, &#x27;Linear SVC&#x27;, &#x27;Decision Tree&#x27;, &#x27;Gradient Boosting Trees&#x27;], &#x27;Score&#x27;: [ acc_knn, acc_log, acc_rf, acc_gaussian, acc_sgd, acc_linear_svc, acc_dt, acc_gbt ]&#125;)models.sort_values(by=&#x27;Score&#x27;, ascending=False) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; Model Score 7 Gradient Boosting Trees 84.53 1 Logistic Regression 84.47 5 Linear SVC 84.42 4 Stochastic Gradient Decent 84.15 2 Random Forest 84.07 0 KNN 81.02 6 Decision Tree 79.93 3 Naive Bayes 75.59 12345678910111213141516models = pd.DataFrame(&#123; &#x27;Model&#x27;: [&#x27;KNN&#x27;, &#x27;Logistic Regression&#x27;, &#x27;Random Forest&#x27;, &#x27;Naive Bayes&#x27;, &#x27;Stochastic Gradient Decent&#x27;, &#x27;Linear SVC&#x27;, &#x27;Decision Tree&#x27;, &#x27;Gradient Boosting Trees&#x27;], &#x27;Score&#x27;: [ acc_cv_knn, acc_cv_log, acc_cv_rf, acc_cv_gaussian, acc_cv_sgd, acc_cv_linear_svc, acc_cv_dt, acc_cv_gbt ]&#125;)models.sort_values(by=&#x27;Score&#x27;, ascending=False) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; Model Score 5 Linear SVC 84.46 7 Gradient Boosting Trees 84.34 1 Logistic Regression 84.33 2 Random Forest 84.05 4 Stochastic Gradient Decent 83.74 0 KNN 81.13 6 Decision Tree 80.44 3 Naive Bayes 74.51 123456789101112131415161718192021222324252627282930313233343536373839404142434445plt.style.use(&#x27;seaborn-whitegrid&#x27;)fig = plt.figure(figsize=(10,10)) models = [ &#x27;KNN&#x27;, &#x27;Logistic Regression&#x27;, &#x27;Random Forest&#x27;, &#x27;Naive Bayes&#x27;, &#x27;Decision Tree&#x27;, &#x27;Gradient Boosting Trees&#x27;]probs = [ probs_knn, probs_log, probs_rf, probs_gau, probs_dt, probs_gbt]colors = [ &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;red&#x27;, &#x27;cyan&#x27;, &#x27;magenta&#x27;, &#x27;yellow&#x27;,] plt.title(&#x27;Receiver Operating Characteristic&#x27;)plt.plot([0, 1], [0, 1],&#x27;r--&#x27;)plt.xlim([-0.01, 1.01])plt.ylim([-0.01, 1.01])plt.ylabel(&#x27;True Positive Rate&#x27;)plt.xlabel(&#x27;False Positive Rate&#x27;)def plot_roc_curves(y_test, prob, model): fpr, tpr, threshold = metrics.roc_curve(y_test, prob) roc_auc = metrics.auc(fpr, tpr) plt.plot(fpr, tpr, &#x27;b&#x27;, label = model + &#x27; AUC = %0.2f&#x27; % roc_auc, color=colors[i]) plt.legend(loc = &#x27;lower right&#x27;) for i, model in list(enumerate(models)): plot_roc_curves(y_test, probs[i], models[i]) plt.show() 123456789101112131415161718192021222324252627282930313233plt.style.use(&#x27;seaborn-whitegrid&#x27;)fig = plt.figure(figsize=(10,10)) models = [ &#x27;Logistic Regression&#x27;, &#x27;Decision Tree&#x27;, ]probs = [ probs_log, probs_dt,]colors = [ &#x27;blue&#x27;, &#x27;green&#x27;,] plt.title(&#x27;Receiver Operating Characteristic&#x27;)plt.plot([0, 1], [0, 1],&#x27;r--&#x27;)plt.xlim([-0.01, 1.01])plt.ylim([-0.01, 1.01])plt.ylabel(&#x27;True Positive Rate&#x27;)plt.xlabel(&#x27;False Positive Rate&#x27;)def plot_roc_curves(y_test, prob, model): fpr, tpr, threshold = metrics.roc_curve(y_test, prob) roc_auc = metrics.auc(fpr, tpr) plt.plot(fpr, tpr, &#x27;b&#x27;, label = model + &#x27; AUC = %0.2f&#x27; % roc_auc, color=colors[i]) plt.legend(loc = &#x27;lower right&#x27;) for i, model in list(enumerate(models)): plot_roc_curves(y_test, probs[i], models[i]) plt.show() 1","categories":[],"tags":[]},{"title":"Small Tools","slug":"SmallTools","date":"2020-10-06T13:48:00.590Z","updated":"2020-10-06T14:40:48.239Z","comments":true,"path":"2020/10/06/SmallTools/","link":"","permalink":"http://muyuhuatang.github.io/2020/10/06/SmallTools/","excerpt":"Some interesting small tools","text":"Some interesting small tools Use small software to use netease music totally freeuse the code below to open the local service 1$ node app.js -p 80:443 -f 223.252.199.66 nondanee/UnblockNeteaseMusic Mac implementation note: use the ip in “Mac implementation” would be just fine. my ping result always can not connect to music.163.com Reference online ip check","categories":[],"tags":[{"name":"Interesting","slug":"Interesting","permalink":"http://muyuhuatang.github.io/tags/Interesting/"}]},{"title":"LeetCode","slug":"LeetCode","date":"2020-10-04T08:05:51.595Z","updated":"2020-10-09T07:13:25.074Z","comments":true,"path":"2020/10/04/LeetCode/","link":"","permalink":"http://muyuhuatang.github.io/2020/10/04/LeetCode/","excerpt":"LeetCode records (In C++/Python 3)","text":"LeetCode records (In C++/Python 3) LeetCode Hot 100 (In leetcode.cn)(2) Add two numbers12345678910111213141516171819202122232425262728293031class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *head = nullptr, *tail = nullptr; int carry = 0; while (l1 || l2) &#123; int n1 = l1 ? l1-&gt;val: 0; int n2 = l2 ? l2-&gt;val: 0; int sum = n1 + n2 + carry; if (!head) &#123; head = tail = new ListNode(sum % 10); &#125; else &#123; tail-&gt;next = new ListNode(sum % 10); tail = tail-&gt;next; &#125; carry = sum / 10; if (l1) &#123; l1 = l1-&gt;next; &#125; if (l2) &#123; l2 = l2-&gt;next; &#125; &#125; if (carry &gt; 0) &#123; tail-&gt;next = new ListNode(carry); &#125; return head; &#125;&#125;;Author：LeetCode-Solution 本质: 链表基本知识与操作 + 取余操作 + 利用整数除后省略小数点的特性技巧: 将取余操作与整除特性结合 + 进位符 -&gt; 模拟数学运算 (20) Valid Parentheses12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool isValid(string s) &#123; // simple check int n = s.size(); if (n % 2 == 1) &#123; return false; &#125; // map function. Could also be applied by if unordered_map&lt;char, char&gt; pairs = &#123; &#123;&#x27;)&#x27;, &#x27;(&#x27;&#125;, &#123;&#x27;]&#x27;, &#x27;[&#x27;&#125;, &#123;&#x27;&#125;&#x27;, &#x27;&#123;&#x27;&#125; &#125;; stack&lt;char&gt; stk; for (char ch: s) &#123; if (pairs.count(ch)) &#123; if (stk.empty() || stk.top() != pairs[ch]) &#123; return false; &#125; stk.pop(); &#125; else &#123; stk.push(ch); &#125; &#125; return stk.empty(); &#125;&#125;;Author：LeetCode-Solution 本质: 数据结构“栈”的基础应用 + 使用Hashmap来简化查找匹配问题技巧: 使用hashmap来作为匹配工具 / 适当使用库函数来减少代码并提升可复用性 (1) Two Sum123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; hashtable; for (int i = 0; i &lt; nums.size(); ++i) &#123; auto it = hashtable.find(target - nums[i]); if (it != hashtable.end()) &#123; // need to return the index in original array return &#123;it-&gt;second, i&#125;; &#125; hashtable[nums[i]] = i; &#125; return &#123;&#125;; &#125;&#125;;Author：LeetCode-Solution 本质 &amp; 技巧: Hash表的使用 Reference LeetCode-cn官网","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://muyuhuatang.github.io/categories/Data-Structure/"},{"name":"LeetCode","slug":"Data-Structure/LeetCode","permalink":"http://muyuhuatang.github.io/categories/Data-Structure/LeetCode/"}],"tags":[{"name":"Record","slug":"Record","permalink":"http://muyuhuatang.github.io/tags/Record/"}]},{"title":"Data Science","slug":"Data-Science","date":"2020-09-25T12:59:55.053Z","updated":"2020-10-04T08:05:28.232Z","comments":true,"path":"2020/09/25/Data-Science/","link":"","permalink":"http://muyuhuatang.github.io/2020/09/25/Data-Science/","excerpt":"Data Science ralated material","text":"Data Science ralated material 行业分析 工程能力 对数据、对业务的理解 机器学习算法与模型 练习 Kaggle天池比赛 在github上follow一些有意思的ML项目 补充知识 BerkeleyX: CS190.1x Scalable Machine Learning CS105x Introduction to Apache Spark Stanford CS231n Convolutional Neural Networks for Visual Recognition","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"http://muyuhuatang.github.io/categories/Data-Science/"}],"tags":[{"name":"Record","slug":"Record","permalink":"http://muyuhuatang.github.io/tags/Record/"}]},{"title":"Academic Records","slug":"Academic-Records","date":"2020-09-25T12:31:30.908Z","updated":"2020-10-11T13:29:12.732Z","comments":true,"path":"2020/09/25/Academic-Records/","link":"","permalink":"http://muyuhuatang.github.io/2020/09/25/Academic-Records/","excerpt":"Records about useful or intersting academic information","text":"Records about useful or intersting academic information Top conferences and journalsMachine LearningNIPS / ICML / neurips / uai / aistats Computer VisionCVPR / ICCV / ECCV / NIPS Data MiningKDD / ICDM / WSDM / SDM / CIK&lt; Natural Language ProcessingACL / EMNLP / NAACL InformationSIGIR / WWW Deep LearningICLR RoboticICRA / IROS / RSS Artifical IntelligenceAAAI / IJCAI Reference","categories":[{"name":"Documents","slug":"Documents","permalink":"http://muyuhuatang.github.io/categories/Documents/"}],"tags":[{"name":"Record","slug":"Record","permalink":"http://muyuhuatang.github.io/tags/Record/"}]},{"title":"Study Records","slug":"Study-Records","date":"2020-09-25T03:43:44.264Z","updated":"2020-10-11T13:30:20.352Z","comments":true,"path":"2020/09/25/Study-Records/","link":"","permalink":"http://muyuhuatang.github.io/2020/09/25/Study-Records/","excerpt":"Records studying useful knowledge","text":"Records studying useful knowledge 课程知识人工智能 机器学习 数据挖掘 统计学习 intersting small models First Order Motion Model for Image Animation 工程应用 统计与概率 工程设计 探索领域工程开发 核心知识 编程语言: Java/C++ 算法与数据结构 数据库 一门技能课 自我提升 平台Coursera、哈佛公开课、斯坦福公开课 基础课程: 计算机科学导论(Havard) 编程平台: Leetcode 初级课程: 深度学习入门、机器学习入门-Stanford CS229、CV入门-CS231N、NLP入门-CS224N 核心要点: 算法与数据结构: Leetcode刷题 数据库+一门技能课的实战: 网页开发 移动端开发-日历、通信软件 云计算-用spark和Hadoop尝试对大数据进行删改读写 AI-推荐系统、搜索系统、CV、NLP 目标: 大厂面试题对答如流 独立完成3-4个编程项目 人工智能与安全推荐系统","categories":[{"name":"Documents","slug":"Documents","permalink":"http://muyuhuatang.github.io/categories/Documents/"}],"tags":[{"name":"Record","slug":"Record","permalink":"http://muyuhuatang.github.io/tags/Record/"}]},{"title":"Intrusion Detection","slug":"Intrusion-Detection","date":"2020-09-24T14:56:09.992Z","updated":"2020-10-10T03:55:26.799Z","comments":true,"path":"2020/09/24/Intrusion-Detection/","link":"","permalink":"http://muyuhuatang.github.io/2020/09/24/Intrusion-Detection/","excerpt":"Intrusion Detection course","text":"Intrusion Detection course Use Lubuntu to test programs in VirtulBox In order to use share function (1) set up shared files (2) when restart Lubuntu, check in terminal “df -l”, and use “sudo mount -t vboxsf [MacSharedFileName] /mnt/shareMac” sudo mount -t vboxsf Shared /mnt/shareMac Install anaconda / Uninstall anaconda Reference How to share files between host-mac and client-virtualbox-Lubuntu How to fix ‘virtualbox failed to get display change request’ error / my solution: change the value of video memory of display settings from 16MB to 64MB would make resolution of display become much higher.","categories":[{"name":"Courses","slug":"Courses","permalink":"http://muyuhuatang.github.io/categories/Courses/"},{"name":"Intrusion Detection","slug":"Courses/Intrusion-Detection","permalink":"http://muyuhuatang.github.io/categories/Courses/Intrusion-Detection/"}],"tags":[{"name":"Courses","slug":"Courses","permalink":"http://muyuhuatang.github.io/tags/Courses/"}]},{"title":"Internet Programming","slug":"Internet-Programming","date":"2020-09-24T14:53:15.808Z","updated":"2020-10-04T08:09:33.024Z","comments":true,"path":"2020/09/24/Internet-Programming/","link":"","permalink":"http://muyuhuatang.github.io/2020/09/24/Internet-Programming/","excerpt":"Internet Programming course","text":"Internet Programming course My","categories":[{"name":"Courses","slug":"Courses","permalink":"http://muyuhuatang.github.io/categories/Courses/"},{"name":"Internet Programming","slug":"Courses/Internet-Programming","permalink":"http://muyuhuatang.github.io/categories/Courses/Internet-Programming/"}],"tags":[{"name":"Courses","slug":"Courses","permalink":"http://muyuhuatang.github.io/tags/Courses/"}]},{"title":"Data Mining","slug":"Data-Mining","date":"2020-09-24T14:49:42.263Z","updated":"2020-10-09T07:13:17.060Z","comments":true,"path":"2020/09/24/Data-Mining/","link":"","permalink":"http://muyuhuatang.github.io/2020/09/24/Data-Mining/","excerpt":"Data Mining course","text":"Data Mining course Classification Problemdataset Basic acknowledge and demo testingEnvironment: anaconda-nevigator / Jupyter-pytorch / sklearn How to implement decision tree classifier model Build projectEnvironment: Docker / Jupyter-tensorflow / sklearn / original reference preprocessing train and test gather data and outcomes compare and analysis draw ROC plot Additional way: use Weka to generate result change .data file into .arff file .data -&gt; .csv (use “sublime text”) -&gt; add label names in .csv (use “sublime text” but not “numbers”) -&gt; use tools to change to .arff, remember to select first row contains labels. use Weka to genarate compare and analysis Reference Use conda environment when facing conda install inconsistency Using label encoding function would lead to error below. 1Encoders require their input to be uniformly strings or numbers. Got [&#x27;float&#x27;, &#x27;str&#x27;] can be fixed by remove the null values in dataset. Basic guide Application guide CSV2ARFF website Label encoding &amp; One-Hot encoding Pandas missing value process methods","categories":[{"name":"Courses","slug":"Courses","permalink":"http://muyuhuatang.github.io/categories/Courses/"},{"name":"Data Mining","slug":"Courses/Data-Mining","permalink":"http://muyuhuatang.github.io/categories/Courses/Data-Mining/"}],"tags":[{"name":"Courses","slug":"Courses","permalink":"http://muyuhuatang.github.io/tags/Courses/"}]},{"title":"Text & Web Mining","slug":"Text-Web-Mining","date":"2020-09-24T14:46:56.354Z","updated":"2020-10-05T08:55:53.545Z","comments":true,"path":"2020/09/24/Text-Web-Mining/","link":"","permalink":"http://muyuhuatang.github.io/2020/09/24/Text-Web-Mining/","excerpt":"Text &amp; Web Mining course","text":"Text &amp; Web Mining course Lab-no2 adjust hyperparameters to get higher accuracy and lower lossOptimize target: Classifying Surnames with a Multilayer Perceptronoriginal code from the textbook website, https://github.com/joosthub/PyTorchNLPBook. Build the best model (based on test loss and test accuracy) by exploring following options: learning_rate batch_size dropout (use only if it helps) batch norm (use only if it helps) weight_decay (L2 regularization) (use only if it helps) hidden_dim Note that it is not necessary to adjust other parameter values even though you are allowed to do so. Values of given parametersThanks for Professor Jin’s suggestion and instruction, I would choose to share some findings when using a slightly different input dataset later on, but not share my answer directly. Best outcomesTest loss: 1.61;Test Accuracy: 57.789 Taking “drewer” as an exampleTop 15 predictions: drewer -&gt; German (p=0.46)drewer -&gt; English (p=0.35)drewer -&gt; Dutch (p=0.06)drewer -&gt; Scottish (p=0.04)drewer -&gt; Czech (p=0.04)drewer -&gt; Polish (p=0.01)drewer -&gt; Spanish (p=0.01)drewer -&gt; French (p=0.01)drewer -&gt; Portuguese (p=0.01)drewer -&gt; Russian (p=0.00)drewer -&gt; Irish (p=0.00)drewer -&gt; Chinese (p=0.00)drewer -&gt; Japanese (p=0.00)drewer -&gt; Italian (p=0.00)drewer -&gt; Arabic (p=0.00) Training SkillsHow to use colab to run ML tasks click “Runtime” -&gt; “Change Runtime Type” -&gt; select GPU or TPU use code below to check GPU status !nvidia-smi build connection between google drive files and this notebook from google.colab import drive drive.mount(‘/content/drive/‘) change dir import os os.chdir(“drive/…/…/“) Do not use same browser to run both Jupyter and Colab, might crash Tips Using VPN would block anaconda-navigator startup, because VPN would probably take up the specific localhost port. homebrew to solve environment path problem. Install graphviz 12brew install graphvizpip install graphviz","categories":[{"name":"Courses","slug":"Courses","permalink":"http://muyuhuatang.github.io/categories/Courses/"},{"name":"Text & Web Mining","slug":"Courses/Text-Web-Mining","permalink":"http://muyuhuatang.github.io/categories/Courses/Text-Web-Mining/"}],"tags":[{"name":"Courses","slug":"Courses","permalink":"http://muyuhuatang.github.io/tags/Courses/"}]},{"title":"Encrypted","slug":"Encrypted","date":"2020-09-24T14:44:45.544Z","updated":"2020-09-25T12:57:58.249Z","comments":true,"path":"2020/09/24/Encrypted/","link":"","permalink":"http://muyuhuatang.github.io/2020/09/24/Encrypted/","excerpt":"Here's something encrypted, password is required to continue reading. Feel free to email me to get the password with fair reason.","text":"Hey, password is required here.77d7535348f6230f63550361cfb8db528ba5fc8bf8a16bd484ce4555d23e1db498f218e407f5f4fd1376813172648eed36c93ab6e576283afeb28b60b802620d10f43f3012706b714f7182fc1ac4714035172207b318c24edd9640b7d68e53cfefaac49c385b05691dbe62d4c01afdd8ee8fd23f35245c11c9612e6977448f6410e1eeeb7cd9e8fa40118efca5fd2c6719355afb101b12770dcd247a02365ef5","categories":[{"name":"Documents","slug":"Documents","permalink":"http://muyuhuatang.github.io/categories/Documents/"}],"tags":[{"name":"Encrypted","slug":"Encrypted","permalink":"http://muyuhuatang.github.io/tags/Encrypted/"}]},{"title":"Information Visualization","slug":"Information-Visualization","date":"2020-09-20T13:57:02.333Z","updated":"2020-10-14T05:44:09.121Z","comments":true,"path":"2020/09/20/Information-Visualization/","link":"","permalink":"http://muyuhuatang.github.io/2020/09/20/Information-Visualization/","excerpt":"Here's something encrypted, password is required to continue reading. Feel free to email me to get the password with fair reason.","text":"Hey, password is required here.81eccbe80038c5fe0d90617ac3e08748835ba8178301bafcff2d6eb5a617a75fce74f2e38c0b66e9c6f6c0c78e5c60809d690e070d7f9f7246daebb6fc48f6965b3c687adf9219b594ce1dc0abfc87ac1f82df4de0b6b8cbc828bffada6d14236081a9e92ae5c9e2b745b419b1309c2951a4e57d0548a19ba03593a493268e586b5c97514d9615f7b2375d561f714e08f262f9fdb96f096d8b18a5d64c55ef85d28e1ce708df08860cd38d19e771be3248cd9d2a35d42a602f18c97c2eb2c7dfaf7d1c45ff898b3bd50ab21069af062633caf31b6416cae6ba3030eae5c079c5516f986e464378bff94cef3bda8e36fffbcf55e3adc267f1afd0037ffff4f466005299d2a4df726bd424762e4799d0ce642ff4d4ac5d0ca58c1a5682ba0b1950b3be8b0e3ee4a75d339ae5c0fe2d10989699e20935da33aa2e32f8e692552f913d082c85dc2bf020d5424e5069a46c42087c8f59ab4f28593951c78177ad8299697bed4d60b9f31d02e24161b31652fde5b6d27199ca81b10d860faf7b059b25288216db17d0c968089214c17b894b31151bb27464c57c0dd341731719da5acb50ed3ea35bafa2f999e910587e997dca6a2c89ca71c951f3d6633bcebc9b6a04c7f48bdd43bf274025c390c1fd1c3c65f8a97aab366af13c0218dc0424c040011117891bbd418b8e79a4643df4086459030b84e2da362e680ab498de0800a3b143fdf6bef0724637f94e7ef4ee949cac1109bf8bc133e7e1c130c056c62972c8d067d86b201598541e795de649246f967454b873cb3b3b9ba5a3571a033d24c7d336413563af081641c415820a3c930230f7e0d9d6b4668f008d4b502a8092c182897e7fa5974252d8c6bd7e466872780ecc3c02de5d5d69f775a22acda3e75082bdd56a874d251b538e83bb2a67f7bb45bd742a653acf8d56d8357bde4cf3bc3619bed91bbf071bd1962ad9b88ce5cb7a3e80bb109991b31241c434c0a08b1122ce8afe7c3f29e8f8af1f42a4e0b44a56f10c98e71a0d744ac9bbd2eaf6f505f4ab75ae183e449ed6ff4b95f6939c326fdc9626bc1ea4c4f3d3c458d3243f34a34953fc85e62a17f4371fc34586c35b56a51c07e26137017818a88565caec0c2ad6a363c353626cfe57275d1440105bdc4279076d6a0db3712d9fe8644496b6af3cc9033c3c9bef48c5686ae343b99fb81dc9dbd41477dcb323ccb191eec2515403aae02ef14f05ecd41eeb957a96a05568dee59966b09666e5eb11c8724c0d0f431ce5606d9399b445efa940c7b979564d9b9d648c18acf199de2173759e780ce7fe639fcc81660e6c6cd3570a7b5459d49621dfc4842103de3d5e00de2fc8025d2a0af79c313ce2866acf01e45abe5368ec9312ba2e8731ad4bb64d8c6885cfdea910287193218f9ef8c92de5fa6a09ba0315ef00290ef79a37d60c949d1e875005b3850dc30adc7a9d6f9e8d545e08e6273dbbea1de9f17684b1ed6aaa31bacfcc1f051a04749034dff73bef7b66aa0948fd21fdd54f3e8377527450ff2c8517ae37d1e5db3b43e50a0cbaa1ea0ba079f18c1d7ef85f47428b88479ef00a948a7cb8d14d35c5075e5b3eec9c1b7d0b9273387b89da89e8d65f3ec3dfd32279e5704c743548c16ceeb830bc7e6e4bb928a4bf9e0b2eba429c8774cbe78b11802134ab2c6ba6e9e4207aacfd8e549393db3682fa186519887abbbd0611b2501e32b32680130c34d6bb553a2b4ad3037d66b690b8981b8497231ca05721a1e293cc9b7c0495025dc04e0cf1cd43444d8d7d64621bffb9abff4038adfd9b96f1f764139702482108e0b5034c07df8affd4ddd4689ea50574e9ac59389287d9cb4b60b8a2a9e2676a788ccbe484309709068e706a5f8c70d5adb83ea68ee56de1b06936e79685b67d76e5e7effaee9821d8d5f7e627cb61323cebd5742d31605e4bed397a6e51f70de7b0b98f3e0a92081b9f2770adfec5e9bdf95837bc7946653585a9adca084f0b338991e958a46c0320ce8468964c9d50ee55adb68afd44bf8f3283df45cb8f45273d7dcba5352377153e2fa2db44d3ec2716b6f322b08fbc4d2ce0deb6a49f4fe6819e9eb8431cba5f854530d96d97dd8e3f31bf44f58f65ef57a0c8aaae56118713f4f0645afd68c57f060ff0b6c74bff65347f3007dd9cd43be01e99a6608476c335c8ed682aa944d92044fe8ae1f0895f8fed039ad91d8dd0a601607a1cb51aad559c0b3af92c4272ee281686b0e1bf99cfd996f41320362b12a7c34e362a54033915a4f8065a01e9aecdb5d777fefe7819e4aabe22d539e6d9b58fde64d05a037e04d418bef5e624c69b65c2cc1ea526f5222b513abc6305ef365157d9fb97fe52e5d8f23da8e2a2bf7c2ae78349cb91519d1f7f902d691c65d684817e517a08221be186545c667c8e3d2c75ddaa991b1bc5d13b2ddcb6e0ab476532f2c0376e54ce9b38957773392ab39198c17210bb83e2794d0eeadf42129055f035e46eef0687466c22f58854f653418ae2b5e0e7163dd071a47306023463e5d4cb9e5e87db810377abf590438697ec26487617a1ae40aa0d07da1fa89d753550faadc358a98eddf427834e941c18ea5289974527f64e33a56e54c2e2ac8479b0679290e2f3b16a391598bc86dddbfa74cafdf7cf533c6b4f3a58825c0401a595a88b241be882e85ba18e0293f25df62b716721c61d418ec93e09f3e9e18bb4f125589e66ad4552ec7a3a5f0e43057fcc674b512c17f1c6d4a5c21f6fbac998d065ab7359e19ac4ee16c11531555446deeed1e38a5191d1054ee0df92f5543099c28675b37ed50192be5d828c0d40938b5fd67036999602825abf37ed5c5e791554deffc808d3a0a7e03d2191de163c61f56f743d6ba52fe022c6f0410f64d83e65766cfddfbe95d86eacafc2aa3f003284ff7a2c8a98a89a3c000e70437435a6bcaa72b4eb3030f490fbd3ead4a1c8cfe646f83f2eb14de1062879f57d3c8914131f39691ea2f4882c6528984a4bb042ea2fb410d083f1f07446dadb426e663d313bfb0f0f89963b5f08ad12647e82087c94ec9bba2bbb6098fa9b90cfb035a29e12ac880cf410c32dad5366a99c5ca055aba690d45f882c56a04a0ee8c792cb629380e5c7acea87cb1e7619a3bc330b2e2df65b12c10ea766ce2ae0b385a8053bee271f028d33b01d2075791b5f71cb9efd6971e0f0ee8ac25d86dc5672fc5fc5c9fc1ac81c12d8083df728c6a61e6be04502c379ee739d1f09d0a599cce8d4b4e8f4475f2be993fe21ee210dbb884bc406c64ed01848d023f1da6a04e8b9893f49dd17ca4c8db0006414fc0db9574d66a24c33adc7d559660af475960c00b386753527acf2271ec29942a7d4e044f5fed69fffb780d4d319bd1217f91c06ae44786a292f1886349f71632edacc707cc52f120f63e7032e6bb47a27cbda27c9cc4b369597710be3854523c0cccfa24ccd6b064c42958babe9bc194de73c50921f653d1c84cc75e3264b70c6ddf93f11c3b1ccd5c77c980d2df7f13d59183673df0b4616d225194c3e32b86372871c1d694a5dc0073cf9c28d42387779518d3110de8fd85da5c11e21ac1b26fab185f114d49506d44b76d3eb26912c0ab404cd262b59a3eae916dc6e2e541792d23026f54880dca223251e0d67fb88a8b7934137dec07c919de4583f040d41227dc272dc6abef8a70a69dd004b0499df6bed11fb3d74266902d00ffd671c3368e93b686f11e847c17671e8b4d29383d9edd970e3c7b117c07798485ed69ddea2719ab581fe607c89db8380166061f463c318266dcf9430ec5f3fc5cb17719a53e66c5c4347f83e4f6b117cbb395799044893d4bd302e6638e1ba40086e5a5ff60b96bc8184d012df275803f06bd1f9200a42e868ff65c297dff68512ced8e2fb6f2237f369929fb3304314100cd2067aa13d727b29a412bdfa29654455ba232217cc9581e3bd790d0b8325339deb7d73dceaf6792e3ee9909f7025512af4e031b9880bf9189ed0cd12b5fab80583a71ed5871b581828977dd905f9085c362dfe9e3a3ed298a5e02b821db9724e13cd3924de9f73374533e02ea9f6719f47ec87b88b8c8cc41f8ba3421a707d12210660f5d3d9c1f02b24a0d035107b49b101c7359261b6a911f4956bfc263dbaa77d9e80c471abea0cc5a34de66eec71a514f21b3f45807f0a62cfc490be3eb31ca017ffc15e3853b9c5d168369bf87455e55f6573b6a7243412b2dca9935734a90476ac380f67468b8f9334f3b44c63e9872147c697ef41a9352a057b782fa0f3cce236b0593c452bf33674398ec91c98ca6793ae4e393e01079831be8e9ad694d75fce51381eb8479a09a865fb7e5259248a70c5cb7914446a3522e28abada523ee8692bac3b69c3c2d74af2c10b0fa688678eb28b6400a329197949857af62bf979f103f8151fb1a51194ee06ef9d2e244eea4ff17724fb5c2d43fe5b28c46b35b25a7527475856a851502939638a040980bf02c7ffedf6c0992558ab3cb800fd2e3033c587c96ff1922dc5dd68b2067c18aa762ca455e20c1f5079b473b466ed8b30c0430ce3eaaa3a6c26e1ba2b1eb602dad914c3fdd3c62320c18f93e4483709d0cc1273ada6147f3fd3225327050fe22d9af67329078e766d497852bc2e97ff24914b7ba55765513c2c7b2b7b44a8fd8483417bd509317ec028947ef14b08b52c048d0683753bb33e543fc30f09739dc59239ecb6d753dff049d260b2ad332315f0b60cb2df83b2ff9d3fd29e1837f63e69c8988ccf2c4929c3e2b6f193a26956f051584cb0b6b91c92a0521453f4fb3dfeda562d3265b71d42e1d445e60323fb92b7b32da19ec9606e3a2dd64aad5e30463174cc4f07bea815ecd625648e43291a5e7ae71206adb09638d48d35db8be9ef4f4a68370847e6b6555c12f31ff44e5accee8af2e6c98750588fbf864440832a459ae32d81466f012bfbb91e3a285e53e785de617fa1cf7216e018a1612fa0f4302bdaaa3b75f59dc74ac2107f0e46f4ba54d527670aecbd9cb2a86ba362f17e424f3ec5a79be6b59fda5e5b14ce24ddce0d49051fa0bf14a62fc29ff31aec911ae96d57bea3a24b370e46bb9d30f05e85db8df5b9508dd96979fc812c263bea3e9348e9e16f86f167b739b8afd403437717ba71898b82c9c28789848bd861f8b76f2b35d2643618b1cc23e409e5d2a20108f8a7330992440071bd0401381d41d0c40cbc3ddc54101192aa0ee513c6039eb5eadd17c5d8b3a23c85dd26c3a9e9b889a24990efd372ec885ee77ac82b28284743ebb005111380a416c7b0659294c89a8d61ddd2022a425e4f31094615e4b1f36af5020ac674737849a81b94fb074d3e0683d83b8a6c4ccc844558b1194a82729a629f5fdd101cbe04fa67466bc395e4875d0524964d8b594c841424d09527af00ce47ea1c39a0365ac1e4cd2e3548f7b7440d4f8ae668c81a813cd4f0904aaef5354260fd85b48a02975c8e91026a1d97333b28195c9bef6da4aef1544a4cb0b44071a2789f3f5b5f4a3c789901e240f9fd5540326a7e366983c17473078290abcc482d85ab34c93ca42dbcb9115309c7878684b26d22d4f9c9dcd437e222e6a2dee54261d7f00e959a7ab93347dc24ae64cd64d669d412cdf5f166d2e30116bc4cdf27b76fc6195b28c26dc30f93dc974955a335184b8dd29c5688d925786bd6be25b7b9945a466b1fe61e7d12052b7a1ada103fafa63621842a9c9cb4bbc07b5da4bcbf8792f7fd9bc2868a01020a1f090f71000cf55edd81309450b5a36023fb0e57724a8fc27404c2eed05175cc69df66b86cecedb4e078d18b27bcb2ac97c94e309a82b1903f3c9c583b1753e0bc864a5e08bba795b42a6bb59d2796b13fbe467ba957b26324782b61c60c1b3880205a9c507b5e31ec5a880138c09d26046a37a6410a1f40bac28756efddf82646f6f49fa7199d97e997aa5b400c2378f7829e8adb01dcca233503eeae46a524c262033213eaaaaee18dbe268f1d038e5ca7f23d2307591bb1c7cc347f586f0a28398ef23c6b06d34ecd002d82b1dc0a59ed0c43ef78aaba30aafeec3b6c0be486565cf006f763779604fddabd2c64f15acb0d36f22cc0f49ba49f02a5ec75f7b18a0e3b7066ad532f69777d1c972e55c99543b35c2fe5da5e1eeb7e06a19fcf9aee56128ad0e2fe3fd7285b0e5b88b6470ca8cca77c4aeb1432b5d2e06b02442e9f292b0fb5382ca411c02bec3f547be92a90c9c200de17dd197a323e3b63ee6e1ee5abc64bfae5d3ba9d7a6fccf9a85f1f6ae3305b25945e97e5a62dcfedc5c8574825d5bdcf5ef2acdd2e39bdb502777cbf8027273ecbe99bef4703643b652e1b33be9538d467a107667c09a5eeffd63ce1802a0906b177f6ad3f10d48b2b6702b1f10de6302d6a570206c5d778098887239d2a4553e3eb0cb079634b8a8c3652030d467632ed286aafa80d8fb471eeb919959eb3649fe81f49e75f8af4441acce3a78104486c4c7dbfb786bccba0dedbd34bff0bda7624f5518984012fbcce0462f6a8e2ce1fb3f8e5b49f8363cd4cbfd21f80d1bea674a0e7f996792d710d7d0e608d970790ff136a151a1f328dd85ab4055558ae57949793caa6aff2cd48471eeeb29181617de44dc2607ec25dfd72fca0c2de96e753351974056dd2df19f7452143b997d5eaaa696a084986044ff5800ef2bf222af745b7bfe4ff709c5db84e53cefcdf74f594464472205087182302db6c4e6a7d8531e77e874ddbc01bc4229a735f6238974fd777bf2be96bfb3dc9effc3a032d06da912d4c044f50ea739d0c290c61496199c00e9de5588829d59896b9929ddda8ef73e2e357dd00e62179b760a956ede997286f1cfacf0f370e47113ae04a4519a1a81d5bdff887bc19ed4a474ac25cc7dbb54d9c894a58333d6bfc4182b7043cb57bbba8bd8c36f09cc384c72873b511b8a543b0b1caa29a6b530a63b8e32dd9ee02a72bea5e335aa52d7818b52baf6a2d637f68bc533853bbfb2008a559220822cbfd4b160550a75365f5cd18db45556cff59628f3707189d78437a2f2ef69f6905bc80cda5dd7839af261cd2028993c80d1435d2011a11e734b7bdb3a5896c4a4f3eb86c67aea351f67ca6f5acbd67c34b2453dd017ddc0fc2d4357a685eef78cfbecd77e1161974d952458555e3389ba51f1d148d2977f781ab1ac3c07eafc96b9192dd21e0c2b7ab04dd6e9b771e8c42ab7043fa819a401fc8053d2a60bb3df8c5e55141709c6ef7fc166f8ad68464bafb47d9a93549105d579828e59182a15faed7eb88ffcf35ac5ce80904b959c8ca76c521fc4df0111552ba8cca04b3cb6e7a2aa043a5ca55592d9da7af629e4a4413df97f8f4f57711337ecc61d60330e41b053839e729d16d65ceef421f38c960d9cfdeb1cc5310edb56df0df783edc77cbe8133165d100fa4834e420b14c93104892c9b9eca97703b44581b27fccb4c46e25df5ffa470c175af2116df5c19d7b83209a399ab739609196efc8e5bbfc0555eeade64f1fc462a01696e46128dbd7373116b659c8149edaafece69d56365cbc04709ddc7bf86fd7b67e8bb547d958392cd8c7a2f99d9cd38d7e597a421c9c9174c6d38462192b10521ee865faf0d6d2ae17b7a76fda411948ae6ba9279770f727d4fc94433b5177d58faf38dcbe93b136de1b1ef9386bfe04c9334c25d04db8c704cc52d5f8501ee2197729b4ba1785cda13977aceb52d183095b802520ed5e524f8de6d0e9b6ba9ab81c671e1ddb7a45659b963957cc12a3e72e46114dbd74aa3696ff37071aa448263f3a9a8b825d954f3175827a05d1a8b91f7c202e77643facc6363212ae504fcd2271ad5d03c6c8fc3541b1cbf1bcff2d7fd37eaf63e932b8ea611296267d8e62e56aff8a1d8c6b8254e2b48a3e3482fccfc0c668d2d673768d95577351c8d3fdf65102c2801b8d2565311410aa3069f8d8b0ea778aa96c42f50766b907197261561b9973a67bfddc1d8f6a26b07169ebe7b5462798c38fbb8389a6eb53f69eed3189afa4dcf13083a18a2cad61572c974954f8a21bd7d3cad9eadbd895b060e9f97ef68858fc59f03c7f7ba650b52ef4b1743aa8c6ccc8521ca1c3449d2f41febfdd70f39b54513ffb64be30865c3c5df865f619cfbb3d346a6386a8db669ab761245a2d6554bef2efe83994ed1ce7aeda3796b24f6d3a88f3d2379f9d3d0c5bbfac2d154df899ba6711780fefa9450269317dad84678279bec0e5941c0845ae70137f360a49366574e97cf1e1c41eb4e33c8daf038b1de9155bf4b218a2e7eb722136206ae4ddb9ebb4dc289e8038b5b6d731d2488671b0038b57f0122ed6a4df8d63eeff9fc331e091209945b532704101c59252f9af11ae5ee5220ea5c60ea4ab68caeb659845db63599415636b7bbdabaec911f578558c28d41fa04dbc159e46f8fd61458531d701b554070b983450d01b451d821eedbd33379576ace401d284290c325128ae706cfb691f4e7835b0cbfd19972b8e1bb17b7027b664039645403cc62d8240f07cfe40da539c7725801d425a9a5ac87418a0a5e90b97e8f42df067dd61826257ba66b81491609c36910fab4e4c01489cba45b8c1bd76641d2b3cd12a253f3dcd77afd2fbe9b41af384c7d2633149748abcc53fe6b16d3eeb3a3de5fb26152ece6f5a091c22ccc37240ac070f1b5f235dbe8e1b5c4f388cd9a08187325b8e183c7d9f2e8ce51e4fd3db73f79d5ab5b7f67dd1ade14034d9ed04edb0bba7c0e5332cfb887a44acb6c1fd3e4caf8f62548e1ca6a023ab91c2dd5d6fe046cbdf2b1da20d105803957b0eb466cf28c16250612de0f3284a9303d0dd5457f1e61636d1ac75b83182cc1f61f1eb35d37b5c71f22e794185fdce2e7ca0f51ffcb2d8c54a47e9041f52a65bea0c84f0fbe8ded231c060540ef88c448f7a081de8130d5a15916d7a5afcfec224b2d5700977f91578288378eb2012b4d8fb3b100731560c2c1c03ccd27030bfe9228967a5d7b013d24bd58d42864e2c0d13afb8c69315bcd715cbead8fe3508391851a5d06e40e1985557a59b1c7627b9c10e39a50010e9f4186540a44f87f0b2d23e5fbf9d908268782fad3445a476a77b195ff2ffb0aab44621223569ade6339453a8b5284d0ca936fdabe4ef8fceb742da80cf1ca1531300ae62a8e4fccf4ba023f747bd05357b0f701f4eb7783f8eb0e67d2a7837b57b04ffdcf10305cc77ba2ecd3016e1e616b2431ebe25510f04c06332811f31bf5154b35db4f82ce3de6e256f33bfdf0364ab89ed3ba40c2f647a736edd89f1f65358018efa1674a174d6b8967f6cba66d16b82d32d2dd8c06d7c2b25149c1dea386cedbca656666cda34b620b9cf4dcbb830360e31c6a2edb37fea264d02b0f37d573f8b1601a85b1ac196c640e9672f4753614d503ae75350ab22c8a56077e8e1ae92e8797d132e788454c1ea66cf6fad528ad7a5136ba71184ad99872407ba208dbf63b81820df2e4a178bd002e794c3079744a42e061b41594441759f69efa817c548d230d4ca2b92ff78eb476f6ed628631422ecc0a7c9559f0ed863f10a65f3c8c354a55a4483938da531ac372856ddd821bc712deae33973bfb1859eeca9554d1c2064cae801f94133be24b3e5ae68473d8eef035270237bf38ef8d1b22bb4018ddacc78710b1799d73f43bb1f34f3ebaa2b264227489f394584d02648a4b5b95a13e724ec2be59c72ccec3384aa0afd7a018660ca09d73c043d7d4df41739f2dfdac36491c3a86719499e8bd33bc380320749506b2c20189200daf65290499c164af6573dc25f13d357f1356ef39fc186ee69afdc4f0abd8814d05e76a30ec68b0fa58af5da141881ca3b2008f7352149f5078ed4d0dd609cf469c43c9d400dfad9b342adfc6a652fb1097bac6fd1bb8f05c49c040f721a6ee181b0b8ae1b249401ec6bba830866d3ef5e34c9a8ad095107b02a55e72300dd97343cb0d75c45d56b3f1d26a844a681f5485dfe936e8710d7d913b8b4a480a6b082abba3a263ee1384499f3833b5896b9a642e376462874f1c8ac991a1c5eb4c9856723ef5b9289f9e1cc8aa98791cf271fd8d937d221ee3441c0aa29454577ec10cd5b024f3a0636529bb450e0b41beaef113dcabdd2e8e08148964bf0b6f3dbcdda578ba2b7f87e09338294d6d92a3fe04c729511694a49ce9dc7210d727ebdf98572abc1251ffdf91d2b641f7c1a6ca0013a5520d36a11acf394b5140c0293bc9dea2a9b75c9bc564f9c05b92d0846d356d0bfce3cf41f45d70dd42a92c326861a8b2c88f5428c5b6e27c11e16ea24a132ddff4e3d94ba21449722e436ba48c2100f350be739be0c71149b828ad04330de38d87024ce8ac17f3829b987f775d8ed94602eacf4cef9219dff83e6ec1761b77e22e294a4d25f718c595cbb8d","categories":[{"name":"Courses","slug":"Courses","permalink":"http://muyuhuatang.github.io/categories/Courses/"},{"name":"Information Visualization","slug":"Courses/Information-Visualization","permalink":"http://muyuhuatang.github.io/categories/Courses/Information-Visualization/"}],"tags":[{"name":"Courses","slug":"Courses","permalink":"http://muyuhuatang.github.io/tags/Courses/"},{"name":"Encrypted","slug":"Encrypted","permalink":"http://muyuhuatang.github.io/tags/Encrypted/"}]},{"title":"Book Notes - Chinese","slug":"Book-notes","date":"2020-09-18T16:17:52.416Z","updated":"2020-09-27T17:16:46.511Z","comments":true,"path":"2020/09/19/Book-notes/","link":"","permalink":"http://muyuhuatang.github.io/2020/09/19/Book-notes/","excerpt":"This is a place I store book notes and related information. The books and the notes here are the Edition in Chinese. 这里也保存了一些优秀的中文版的图书的读书笔记.","text":"This is a place I store book notes and related information. The books and the notes here are the Edition in Chinese. 这里也保存了一些优秀的中文版的图书的读书笔记. Notes when reading:Notes collection - Computer Science/Four Element Courses Reading notes: 《学术研究,你的成功之道》凌晓峰,杨强 著 研究生期间比较好的节奏: 认真学习,努力钻研,心无旁骛,培养起较强的独立科研工作能力 锤子 + 钉子 理论 兴趣是研究的动力,创新是研究的核心,影响力是研究的成绩单 随笔记录: 《风格的要素》 威廉斯托克 著 王书淮 译英语用法的八个基本规则 单数名词末尾加‘s,构成名词所有格 叙述一系列超过三个以上的名词,在最后一个名词前使用连接词,其余的每个名词以逗号隔开 将作附加说明的插入语放在两个逗号中间 以连接词and或but引导完整的句子时,连接词的前面要加逗号 不可以用逗号直接连接两个完整的句子 不可以讲完整的句子任意拆分成两部分 句首的分词短语所指代的主语应与主句的主语保持一致 在行末需要将单词拆分是,必须遵守构词和发音的规则. 英语写作的十个基本原则 以段落为写作的基本单位,每个段落有其中心主旨 在段落的开始使用主旨句点题,段落的结尾与主旨句相呼应 使用主动语态 使用肯定句陈述 省略冗词 避免连续使用结构松散的句子 以相似的句型结构叙述对等的概念 将相关的词放在一起 总结叙述时,要使用同一时态 将需要强调的词或词组放在句子末尾 随笔记录: Reference: 《学术研究,你的成功之道》- 豆瓣 《风格的要素》- 当当","categories":[{"name":"BookNotes","slug":"BookNotes","permalink":"http://muyuhuatang.github.io/categories/BookNotes/"}],"tags":[{"name":"Records","slug":"Records","permalink":"http://muyuhuatang.github.io/tags/Records/"},{"name":"BookNotes","slug":"BookNotes","permalink":"http://muyuhuatang.github.io/tags/BookNotes/"}]},{"title":"Python Learning","slug":"Python-Learning","date":"2020-09-08T09:47:33.205Z","updated":"2020-09-25T12:58:23.626Z","comments":true,"path":"2020/09/08/Python-Learning/","link":"","permalink":"http://muyuhuatang.github.io/2020/09/08/Python-Learning/","excerpt":"The introduciton of Python and some notes when learning","text":"The introduciton of Python and some notes when learning Notes for 《Learn Python The Hard Way》: Use PEMDAS(Parentheses Exponents Multiplication Division Addition Subtraction) to help remeber the calculating priority. Could use “%r” to debug because it will show the raw data of the parameter. Command Line programming is very important for beginners. Reference: 《Learn Python The Hard Way》 This book is suitable for person who did not know much about Computer Programming and Python before. This book indicate some good habits programer should posses, which I believe is very good for beginners. Reading time apporximately is","categories":[{"name":"Programming Language","slug":"Programming-Language","permalink":"http://muyuhuatang.github.io/categories/Programming-Language/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"http://muyuhuatang.github.io/tags/Notes/"},{"name":"Python","slug":"Python","permalink":"http://muyuhuatang.github.io/tags/Python/"}]},{"title":"Blog start-up and settings","slug":"blog","date":"2020-09-03T17:50:15.401Z","updated":"2020-10-08T11:57:02.509Z","comments":true,"path":"2020/09/04/blog/","link":"","permalink":"http://muyuhuatang.github.io/2020/09/04/blog/","excerpt":"Welcome to Mysite!","text":"Welcome to Mysite! Hexo Official ReferenceHexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Hexo TipsCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment References:Building: How to build this blog and some small improvements How to deploy Articles How to optimize Visualization Performance of Next - 1 - 2 Tips: only for reference, many method in these two pages are outdate. Adjusting: How to activate “tags” and “categories” functionsStep 1Step 2 How to enable the search function in blog How to add “top” function Tips: 1) the value of &quot;top&quot; tag bigger, the rank of article higher Word count and read time function Visiting number count function Tips: 1) This is an embedded plugin in NexT theme 2) the homepage of [&quot;busuanzi&quot;](http://ibruce.info/2015/04/04/busuanzi/) Use Taobao npm to accelerate installation process Modifying/Updating: Use hexo-hey to manage Blog hexo-hey github source code page How to store the images in github repository 2.1. (Recommand)Use plug-in unit of relative routine / Embedding an image using markdown 2.1.1. Plug-in unit format: put the image in “source/_post/[your new article’s tile]/“ 1&#123;% asset_img [imageFullName] [imamge descirption]] %&#125; 2.1.2. Embedding an image using markdown: do not have to put the in the specific “public” file because the image there would be automatically generated if you have put the image in the “source/_post/[your new article’s tile]/“ 1![[descirption]]([imageFullName]) 2.2. (Sometimes would fail to load)Use hexo-hey funtion Put the image in the “source/images/“: I changed 236th row in file “node_modules/hexo-hey/api.js” with this step and adjust 1filename: hexo.config.url + &#x27;/&#x27; + req.file.filename to 1filename: &#x27;/&#x27; + req.file.filename So, I could use the format below: 1![[descirption]](/images/[imageFullName]) How to preview pdf files in Blog Github: Hexo-pdf Use object tag &amp; asset_floder to load pdf 12&lt;object data=&quot;./[pdfFullName]&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;800px&quot;&gt;&lt;/object&gt;&lt;object data=&quot;[previewURL]&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;800px&quot;&gt;&lt;/object&gt; Tips: 1) set height as specific px but not percentage. 2) use local reference first, because URL need much more time to load. 3) if you want to insert a pdf file in &quot;about&quot; page, you should put the file directly in &quot;source/about/&quot; How to use encrypt function for specific articles Tips: 1) download of hexo-blog-encrypt may fail using npm method, try yarn method instead. 2) TOC function may disable encrypted article loading, so you can set toc as &#39;false&#39; in config file of theme. How to add canvas special effects Canvas-ribbon Canvas-three How to recommand related articles at the bottom How to out Jupyter notebook in hexo————unstable and not available now. Should ues “download the file in jupyter as MD file” + “ hide article in hexo net”","categories":[{"name":"Documents","slug":"Documents","permalink":"http://muyuhuatang.github.io/categories/Documents/"}],"tags":[{"name":"Records","slug":"Records","permalink":"http://muyuhuatang.github.io/tags/Records/"}]}],"categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://muyuhuatang.github.io/categories/Data-Structure/"},{"name":"LeetCode","slug":"Data-Structure/LeetCode","permalink":"http://muyuhuatang.github.io/categories/Data-Structure/LeetCode/"},{"name":"Data Science","slug":"Data-Science","permalink":"http://muyuhuatang.github.io/categories/Data-Science/"},{"name":"Documents","slug":"Documents","permalink":"http://muyuhuatang.github.io/categories/Documents/"},{"name":"Courses","slug":"Courses","permalink":"http://muyuhuatang.github.io/categories/Courses/"},{"name":"Intrusion Detection","slug":"Courses/Intrusion-Detection","permalink":"http://muyuhuatang.github.io/categories/Courses/Intrusion-Detection/"},{"name":"Internet Programming","slug":"Courses/Internet-Programming","permalink":"http://muyuhuatang.github.io/categories/Courses/Internet-Programming/"},{"name":"Data Mining","slug":"Courses/Data-Mining","permalink":"http://muyuhuatang.github.io/categories/Courses/Data-Mining/"},{"name":"Text & Web Mining","slug":"Courses/Text-Web-Mining","permalink":"http://muyuhuatang.github.io/categories/Courses/Text-Web-Mining/"},{"name":"Information Visualization","slug":"Courses/Information-Visualization","permalink":"http://muyuhuatang.github.io/categories/Courses/Information-Visualization/"},{"name":"BookNotes","slug":"BookNotes","permalink":"http://muyuhuatang.github.io/categories/BookNotes/"},{"name":"Programming Language","slug":"Programming-Language","permalink":"http://muyuhuatang.github.io/categories/Programming-Language/"}],"tags":[{"name":"Interesting","slug":"Interesting","permalink":"http://muyuhuatang.github.io/tags/Interesting/"},{"name":"Record","slug":"Record","permalink":"http://muyuhuatang.github.io/tags/Record/"},{"name":"Courses","slug":"Courses","permalink":"http://muyuhuatang.github.io/tags/Courses/"},{"name":"Encrypted","slug":"Encrypted","permalink":"http://muyuhuatang.github.io/tags/Encrypted/"},{"name":"Records","slug":"Records","permalink":"http://muyuhuatang.github.io/tags/Records/"},{"name":"BookNotes","slug":"BookNotes","permalink":"http://muyuhuatang.github.io/tags/BookNotes/"},{"name":"Notes","slug":"Notes","permalink":"http://muyuhuatang.github.io/tags/Notes/"},{"name":"Python","slug":"Python","permalink":"http://muyuhuatang.github.io/tags/Python/"}]}